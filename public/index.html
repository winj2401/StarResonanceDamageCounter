<!doctype html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>æ˜Ÿç—•å…±é¸£å®æ—¶æˆ˜æ–—æ•°æ®</title>
        <script src="echarts.min.js"></script>
        <script src="socket.io.min.js"></script>
        <link rel="stylesheet" type="text/css" href="css/style.css" />
    </head>

    <body>
        <h1 id="appTitle">ğŸ¯ æ˜Ÿç—•å…±é¸£å®æ—¶æˆ˜æ–—æ•°æ®å±•ç¤º</h1>
        <div style="margin: 20px 0"></div>
        <button class="main-button" onclick="clearData()">ğŸ—‘ï¸ æ¸…ç©ºæ•°æ®</button>
        <button class="main-button" id="pauseButton" onclick="togglePause()">â¸ï¸ æš‚åœç»Ÿè®¡</button>
        <button class="main-button" onclick="openHpWindow()">â¤ï¸ è¡€æ¡ç›‘æ§</button>
        <button class="main-button" onclick="toggleHistoryModal()">ğŸ“œ å†å²æ•°æ®</button>
        <button class="main-button" onclick="toggleDarkMode()">ğŸŒ™ å¤œé—´æ¨¡å¼</button>
        <button class="main-button" onclick="toggleSimpleMode()">ğŸ“‹ ç®€æ´æ¨¡å¼</button>
        <button class="main-button" onclick="toggleControlsModal()">ğŸ‘¤ ç”¨æˆ·ç®¡ç†</button>
        <button class="main-button" onclick="toggleSettingsModal()">âš™ï¸ ç»Ÿè®¡è®¾ç½®</button>

        <!-- å†å²æ•°æ®å¼¹çª— -->
        <div id="historyModal" class="modal">
            <div class="modal-content" style="width: 95vw; max-width: 95vw; max-height: 95vh; margin: 1% auto">
                <div class="modal-header">
                    <h2 class="modal-title">ğŸ“œ å†å²æ•°æ®</h2>
                    <span class="close-button" onclick="toggleHistoryModal()">&times;</span>
                </div>
                <div class="modal-body" style="padding: 0px">
                    <iframe id="historyIframe" class="history-iframe"></iframe>
                </div>
            </div>
        </div>

        <!-- æ§åˆ¶é¢æ¿å¼¹çª— -->
        <div id="controlsModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">ğŸ‘¤ ç”¨æˆ·æ§åˆ¶é¢æ¿</h2>
                    <span class="close-button" onclick="toggleControlsModal()">&times;</span>
                </div>
                <div class="modal-body">
                    <div style="margin-bottom: 15px; text-align: center">
                        <button onclick="toggleAllUsers()">ğŸ”„ å…¨é€‰/å–æ¶ˆå…¨é€‰</button>
                        <button onclick="clearNicknames()">ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰æ˜µç§°</button>
                    </div>
                    <div
                        id="userControlsList"
                        style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; max-height: 400px; overflow-y: auto"
                    >
                        <!-- ç”¨æˆ·æ§åˆ¶é¡¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
            </div>
        </div>

        <!-- è®¾ç½®å¼¹çª— -->
        <div id="settingsModal" class="modal">
            <div class="modal-content" style="width: 400px; max-width: 95vw; margin: 5% auto">
                <div class="modal-header">
                    <h2 class="modal-title">âš™ï¸ ç»Ÿè®¡è®¾ç½®</h2>
                    <span class="close-button" onclick="toggleSettingsModal()">&times;</span>
                </div>
                <div class="modal-body">
                    <form id="settingsForm">
                        <label><input type="checkbox" id="settingAutoClearOnServerChange" /> åˆ‡å›¾åˆ‡çº¿åè‡ªåŠ¨åˆ†æ®µæ•°æ®</label><br />
                        <label><input type="checkbox" id="settingAutoClearOnTimeout" /> 15ç§’æœªæˆ˜æ–—è‡ªåŠ¨åˆ†æ®µæ•°æ®</label><br />
                        <label><input type="checkbox" id="settingOnlyRecordEliteDummy" /> åªè®°å½•åä¼šç²¾è‹±æœ¨æ¡©æ•°æ®</label><br />
                        <button type="button" onclick="saveSettings()" style="margin-top: 15px">ä¿å­˜è®¾ç½®</button>
                    </form>
                </div>
            </div>
        </div>

        <!-- æŠ€èƒ½ç»Ÿè®¡å¼¹çª— -->
        <div id="skillModal" class="skill-modal">
            <div class="skill-modal-content">
                <div class="skill-modal-header">
                    <h2 class="skill-modal-title">
                        <i class="icon">ğŸ“Š</i>
                        <span id="skillUserName">æŠ€èƒ½å‚ä¸ç»Ÿè®¡</span>
                    </h2>
                    <span class="skill-modal-close" onclick="closeSkillModal()">&times;</span>
                </div>
                <div class="skill-modal-body">
                    <div class="skill-user-info">
                        <div class="skill-user-info-item">
                            <div class="skill-user-info-label">ç”¨æˆ·ID</div>
                            <div class="skill-user-info-value" id="skillUserId">-</div>
                        </div>
                        <div class="skill-user-info-item">
                            <div class="skill-user-info-label">è§’è‰²æ˜µç§°</div>
                            <div class="skill-user-info-value" id="skillUserNickname">-</div>
                        </div>
                        <div class="skill-user-info-item">
                            <div class="skill-user-info-label">èŒä¸š</div>
                            <div class="skill-user-info-value" id="skillUserProfession">-</div>
                        </div>
                        <div class="skill-user-info-item">
                            <div class="skill-user-info-label">æˆ˜åŠ›è¯„åˆ†</div>
                            <div class="skill-user-info-value" id="fightPoint">-</div>
                        </div>
                        <div class="skill-user-info-item">
                            <div class="skill-user-info-label">æœ€å¤§HP</div>
                            <div class="skill-user-info-value" id="maxHp">-</div>
                        </div>
                        <div class="skill-user-info-item">
                            <div class="skill-user-info-label">æŠ€èƒ½æ•°é‡</div>
                            <div class="skill-user-info-value" id="skillCount">-</div>
                        </div>
                    </div>

                    <div class="skill-stats-container">
                        <div class="skill-chart-container" id="skillDamageChart"></div>
                        <div class="skill-chart-container" id="skillCritChart"></div>
                    </div>

                    <div class="skill-table-container">
                        <table class="skill-table" id="skillTable">
                            <thead>
                                <tr>
                                    <th>æŠ€èƒ½åç§°</th>
                                    <th>ç±»å‹</th>
                                    <th>å…ƒç´ </th>
                                    <th>æ€»æ•°å€¼</th>
                                    <th>ä½¿ç”¨æ¬¡æ•°</th>
                                    <th>æš´å‡»ç‡</th>
                                    <th>å¹¸è¿è§¦å‘ç‡</th>
                                    <th>æš´å‡»æ•°å€¼</th>
                                    <th>æ™®é€šæ•°å€¼</th>
                                </tr>
                            </thead>
                            <tbody id="skillTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- ç‰ˆæœ¬æ›´æ–°å¼¹çª— -->
        <div id="updateModal" class="update-modal">
            <div class="update-modal-content">
                <div class="update-modal-header">
                    <h2 class="update-modal-title">ğŸš€ å‘ç°æ–°ç‰ˆæœ¬</h2>
                    <button class="update-modal-close" onclick="closeUpdateModal()">&times;</button>
                </div>
                <div class="update-modal-body">
                    <p>æ£€æµ‹åˆ°æœ‰æ–°ç‰ˆæœ¬å¯ç”¨ï¼Œå»ºè®®åŠæ—¶æ›´æ–°ä»¥è·å¾—æœ€ä½³ä½¿ç”¨ä½“éªŒï¼</p>

                    <div class="version-info">
                        <div class="current-version">
                            <span>å½“å‰ç‰ˆæœ¬</span>
                            <span id="currentVersionText">---</span>
                        </div>
                        <div class="latest-version">
                            <span>æœ€æ–°ç‰ˆæœ¬</span>
                            <span id="latestVersionText">---</span>
                        </div>
                    </div>

                    <div class="update-buttons">
                        <a id="downloadLink" href="#" target="_blank" class="update-btn update-btn-primary"> ğŸ“¥ å‰å¾€ä¸‹è½½ </a>
                        <button onclick="closeUpdateModal()" class="update-btn update-btn-secondary">â­ï¸ ç¨åæé†’</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- æœåŠ¡å™¨çŠ¶æ€æç¤º -->
        <div id="serverStatus" class="server-status">
            <span id="serverStatusText">è¿æ¥ä¸­...</span>
        </div>

        <!-- DPSæŠ˜çº¿å›¾ -->
        <div class="chart-container">
            <h3 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center">
                ğŸ“ˆ DPSè¶‹åŠ¿
                <div style="display: flex; align-items: center; gap: 10px">
                    <span id="chartStatus" style="font-size: 12px; color: #666; font-weight: normal"></span>
                    <button
                        id="chartToggleBtn"
                        onclick="toggleChartVisibility()"
                        style="
                            background: none;
                            border: none;
                            font-size: 16px;
                            cursor: pointer;
                            padding: 5px;
                            border-radius: 3px;
                            transition: background-color 0.2s;
                        "
                    >
                        <svg
                            width="20"
                            height="20"
                            viewBox="0 0 16 16"
                            fill="none"
                            stroke="currentColor"
                            stroke-width="2"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        >
                            <polyline points="6,10 8,8 10,10"></polyline>
                        </svg>
                    </button>
                </div>
            </h3>
            <div id="dpsChartContent" style="transition: all 0.3s ease; overflow: hidden">
                <div id="dpsChart" style="width: 100%; height: 350px"></div>
            </div>
        </div>

        <div class="card">
            <div style="margin: 20px 0">
                <label for="sortSelect" style="margin-right: 10px; font-weight: bold">æ’åºæ–¹å¼:</label>
                <select
                    id="sortSelect"
                    onchange="updateSortMode()"
                    style="padding: 8px 12px; font-size: 14px; border-radius: 5px; border: 1px solid #ddd; background-color: white"
                >
                    <option value="uid">æŒ‰UIDæ’åº (å‡åº)</option>
                    <option value="fightPoint">æŒ‰è¯„åˆ†æ’åº (é™åº)</option>
                    <option value="takenDamage">æŒ‰æ‰¿ä¼¤æ’åº (é™åº)</option>
                    <option value="damage">æŒ‰æ€»ä¼¤å®³æ’åº (é™åº)</option>
                    <option value="dps">æŒ‰æ€»DPSæ’åº (é™åº)</option>
                    <option value="realtimeDpsMax">æŒ‰æœ€å¤§ç¬æ—¶DPSæ’åº (é™åº)</option>
                    <option value="healing">æŒ‰æ€»æ²»ç–—æ’åº (é™åº)</option>
                    <option value="hps">æŒ‰æ€»HPSæ’åº (é™åº)</option>
                    <option value="realtimeHpsMax">æŒ‰æœ€å¤§ç¬æ—¶HPSæ’åº (é™åº)</option>
                    <option value="hp_min">æŒ‰å‰©ä½™HPæ’åº (å‡åº)</option>
                </select>
            </div>
            <!-- æ•°æ®ç»„æ˜¾ç¤ºæ§åˆ¶ -->
            <div class="data-group-controls">
                <button id="damageGroupBtn" class="data-group-button active" onclick="toggleDataGroup('damage')">âš”ï¸ ä¼¤å®³&DPS</button>
                <button id="healingGroupBtn" class="data-group-button" onclick="toggleDataGroup('healing')">â¤ï¸ æ²»ç–—&HPS</button>
                <button id="allGroupBtn" class="data-group-button" onclick="toggleDataGroup('all')">ğŸ“Š å…¨éƒ¨æ•°æ®</button>
                <button id="hideInactiveBtn" class="data-group-button" onclick="toggleHideInactiveUsers()">ğŸ‘€ éšè—æœªå‚æˆ˜</button>
                <button class="data-group-button" onclick="openColumnSettings()">âš™ï¸ è¡¨æ ¼è®¾ç½®</button>
            </div>
            <div class="table-container">
                <table id="damageTable">
                    <thead>
                        <tr>
                            <th rowspan="2" title="è§’è‰²å”¯ä¸€æ ‡è¯†ç¬¦">è§’è‰²ID</th>
                            <th rowspan="2" title="è§’è‰²æ˜µç§°/è‡ªå®šä¹‰æ˜µç§°">è§’è‰²æ˜µç§°</th>
                            <th rowspan="2" title="è§’è‰²èŒä¸š">èŒä¸š</th>
                            <th rowspan="2" title="è§’è‰²è¯„åˆ†">è¯„åˆ†</th>
                            <th rowspan="2" title="è§’è‰²è¡€é‡">HP</th>
                            <th rowspan="2" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­å—åˆ°çš„ä¼¤å®³">æ‰¿ä¼¤</th>
                            <th rowspan="2" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­æ­»äº¡æ¬¡æ•°">æ­»äº¡</th>
                            <th rowspan="2" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æš´å‡»ä¼¤å®³æ¬¡æ•°å æ€»ä¼¤å®³æ¬¡æ•°çš„æ¯”ä¾‹">æš´å‡»ç‡</th>
                            <th rowspan="2" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„å¹¸è¿ä¼¤å®³æ¬¡æ•°å æ€»ä¼¤å®³æ¬¡æ•°çš„æ¯”ä¾‹">å¹¸è¿ç‡</th>
                            <th class="damage-main-col" colspan="4">ä¼¤å®³</th>
                            <th class="damage-simple-col" style="display: none" colspan="1">ä¼¤å®³</th>
                            <th class="dps-col" colspan="3">DPS</th>
                            <th class="healing-main-col" colspan="4">æ²»ç–—</th>
                            <th class="healing-simple-col" style="display: none" colspan="1">æ²»ç–—</th>
                            <th class="hps-col" colspan="3">HPS</th>
                            <th rowspan="2">æ“ä½œ</th>
                        </tr>
                        <tr>
                            <th class="damage-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„æ€»ä¼¤å®³">æ€»ä¼¤å®³</th>
                            <th class="damage-detail-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„éå¹¸è¿çš„æš´å‡»ä¼¤å®³">çº¯æš´å‡»</th>
                            <th class="damage-detail-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„éæš´å‡»çš„å¹¸è¿ä¼¤å®³">çº¯å¹¸è¿</th>
                            <th class="damage-detail-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„æš´å‡»çš„å¹¸è¿ä¼¤å®³">æš´å‡»å¹¸è¿</th>
                            <th class="dps-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æœ€è¿‘ä¸€ç§’é€ æˆçš„ä¼¤å®³">ç¬æ—¶DPS</th>
                            <th class="dps-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æœ€å¤§ç¬æ—¶DPS">æœ€å¤§ç¬æ—¶</th>
                            <th class="dps-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æ€»DPSï¼ˆä»¥ç¬¬ä¸€æ¬¡æŠ€èƒ½ä¸æœ€åä¸€æ¬¡æŠ€èƒ½ä¹‹é—´çš„æ—¶é—´ä½œä¸ºæœ‰æ•ˆæˆ˜æ–—æ—¶é—´è®¡ç®—ï¼‰">æ€»DPS</th>
                            <th class="healing-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„æ€»æ²»ç–—é‡">æ€»æ²»ç–—</th>
                            <th class="healing-detail-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„éå¹¸è¿çš„æš´å‡»æ²»ç–—é‡">çº¯æš´å‡»</th>
                            <th class="healing-detail-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„éæš´å‡»çš„å¹¸è¿æ²»ç–—é‡">çº¯å¹¸è¿</th>
                            <th class="healing-detail-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„æš´å‡»çš„å¹¸è¿æ²»ç–—é‡">æš´å‡»å¹¸è¿</th>
                            <th class="hps-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æœ€è¿‘ä¸€ç§’é€ æˆçš„ä¼¤å®³å’Œæ²»ç–—é‡">ç¬æ—¶HPS</th>
                            <th class="hps-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æœ€å¤§ç¬æ—¶HPS">æœ€å¤§ç¬æ—¶</th>
                            <th class="hps-cols" title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æ€»HPSï¼ˆä»¥ç¬¬ä¸€æ¬¡æŠ€èƒ½ä¸æœ€åä¸€æ¬¡æŠ€èƒ½ä¹‹é—´çš„æ—¶é—´ä½œä¸ºæœ‰æ•ˆæˆ˜æ–—æ—¶é—´è®¡ç®—ï¼‰">æ€»HPS</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <footer style="margin-top: 40px; font-size: 14px; color: #888">
            <span>Â© 2025 Made with â¤ï¸ by </span>
            <a href="https://github.com/dmlgzs/" target="_blank">Dimole</a>
            <span> and </span>
            <a href="https://github.com/dmlgzs/StarResonanceDamageCounter/graphs/contributors" target="_blank">Other Contributors</a>
            <span> | </span>
            <a href="https://github.com/dmlgzs/StarResonanceDamageCounter" target="_blank">GitHub</a>
        </footer>

        <script>
            let currentSortMode = 'uid'; // é»˜è®¤æŒ‰UIDæ’åº
            let userNicknames = JSON.parse(localStorage.getItem('userNicknames') || '{}');
            let visibleUsers = JSON.parse(localStorage.getItem('visibleUsers') || '{}');
            let dpsHistory = {}; // å­˜å‚¨æ¯ä¸ªç”¨æˆ·çš„DPSå†å²æ•°æ®
            let chart = null;
            const HISTORY_DURATION_SECONDS = 60; // å†å²è®°å½•æ—¶é•¿ï¼ˆç§’ï¼‰
            const HISTORY_FREQUENCY_PER_SECOND = 10; // æ¯ç§’è®°å½•æ¬¡æ•°
            const MAX_HISTORY_LENGTH = HISTORY_DURATION_SECONDS * HISTORY_FREQUENCY_PER_SECOND; // 60ç§’ * 10æ¬¡/ç§’
            let chartDatasetMap = {}; // ç¼“å­˜æ•°æ®é›†ç´¢å¼•ï¼Œé¿å…é‡å»º
            let lastUpdateTime = 0;
            let chartInitialized = false; // æ ‡è®°å›¾è¡¨æ˜¯å¦å·²åˆå§‹åŒ–
            let userColorMap = {}; // ç”¨æˆ·å›ºå®šé¢œè‰²æ˜ å°„
            let isUpdatingFromLegend = false; // é˜²æ­¢å›¾ä¾‹äº‹ä»¶å’Œæ§åˆ¶é¢æ¿äº‹ä»¶ç›¸äº’è§¦å‘
            let currentUserArray = []; // ç¼“å­˜å½“å‰ç”¨æˆ·æ•°ç»„ç”¨äºæŸ¥æ‰¾ç”¨æˆ·å

            // yè½´åŠ¨æ€è°ƒæ•´ç›¸å…³å˜é‡
            const Y_AXIS_FLOOR_MIN = 10000;

            // WebSocketè¿æ¥ç›¸å…³å˜é‡
            let socket = null;
            let isWebSocketConnected = false;
            let lastWebSocketMessage = Date.now();
            let webSocketReconnectAttempts = 0;
            let fallbackToAPI = false;
            let apiInterval = null;

            // æš‚åœç»Ÿè®¡ç›¸å…³å˜é‡
            let isPaused = false;

            // æœåŠ¡å™¨çŠ¶æ€æç¤ºç›¸å…³å˜é‡
            let serverStatusTimeout = null;

            // æ•°æ®ç»„æ˜¾ç¤ºæ§åˆ¶ç›¸å…³å˜é‡
            let currentDataGroup = 'damage';
            let lastVisiableUserArray = [];

            // éšè—æœªå‚æˆ˜è§’è‰²ç›¸å…³å˜é‡
            let hideInactiveUsers = false;

            // æ–°å¢æŠ€èƒ½åˆ†æåŠŸèƒ½
            let skillChart1 = null;
            let skillChart2 = null;
            let currentSkillUserId = 0;

            // å›¾è¡¨æ˜¾ç¤º/éšè—æ§åˆ¶ç›¸å…³å˜é‡
            let isChartVisible = true;

            // ç‰ˆæœ¬æ£€æŸ¥ç›¸å…³å˜é‡
            const CURRENT_VERSION = '3.1';
            const GITHUB_REPO = 'dmlgzs/StarResonanceDamageCounter';
            const UPDATE_CHECK_INTERVAL = 4 * 60 * 60 * 1000;

            // ä»seriesæ•°æ®ä¸­æå–å¯è§æœ€å¤§å€¼
            function getVisibleMaxFromSeries(seriesArray) {
                let m = 0;
                for (const series of seriesArray) {
                    const arr = series.data || [];
                    for (let i = 0; i < arr.length; i++) {
                        const v = arr[i];
                        if (typeof v === 'number') m = Math.max(m, v);
                    }
                }
                return m;
            }

            // å°†æ•°å€¼å‘ä¸Šå–æ•´åˆ°å¥½è¯»çš„æ¡£ä½
            function niceCeil(val) {
                if (val <= 0) return 1000;
                const exp = Math.pow(10, Math.floor(Math.log10(val)));
                const bases = [1, 2, 2.5, 5, 10, 20, 25, 50, 100];
                for (const b of bases) {
                    const candidate = b * exp;
                    if (candidate >= val) return candidate;
                }
                return Math.ceil(val / exp) * exp;
            }

            // å¤åˆ¶ç”¨æˆ·æ•°æ®
            function copyUserData(userId) {
                const user = getUserFromArray(userId);
                if (!user) {
                    console.error('æœªæ‰¾åˆ°ç”¨æˆ·æ•°æ®');
                    return;
                }

                const hasValidName = user.name && user.name.trim() !== '';
                const nickname = userNicknames[userId] || (hasValidName ? user.name : '') || '';
                const copyText = `${nickname}#${userId} ä¼¤å®³:${user.total_damage.total} æ²»ç–—:${user.total_healing.total} DPS:${user.total_dps.toFixed(2)} HPS:${user.total_hps.toFixed(2)}`;

                // å¤åˆ¶æ˜µç§°åˆ°å‰ªè´´æ¿
                navigator.clipboard
                    .writeText(copyText)
                    .then(() => {
                        // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæç¤º
                        showCopySuccess();
                    })
                    .catch((err) => {
                        console.error('å¤åˆ¶å¤±è´¥:', err);
                        // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•å¤åˆ¶
                        try {
                            const textArea = document.createElement('textarea');
                            textArea.value = copyText;
                            document.body.appendChild(textArea);
                            textArea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textArea);
                            showCopySuccess();
                        } catch (e) {
                            console.error('é™çº§å¤åˆ¶æ–¹æ¡ˆä¹Ÿå¤±è´¥:', e);
                        }
                    });
            }

            // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæç¤º
            function showCopySuccess() {
                // åˆ›å»ºä¸´æ—¶æç¤ºå…ƒç´ 
                const toast = document.createElement('div');
                toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4CAF50;
                color: white;
                padding: 10px 20px;
                border-radius: 4px;
                z-index: 10000;
                font-size: 14px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                animation: slideIn 0.3s ease-out;
            `;
                toast.textContent = 'âœ… å·²å¤åˆ¶ç”¨æˆ·æ•°æ®';
                document.body.appendChild(toast);

                // 3ç§’åç§»é™¤æç¤º
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 3000);
            }

            // æ˜¾ç¤ºæŠ€èƒ½åˆ†æå¼¹çª—
            async function showSkillAnalysis(userId) {
                currentSkillUserId = userId;
                const modal = document.getElementById('skillModal');
                modal.style.display = 'block';

                // è·å–æŠ€èƒ½æ•°æ®
                await fetchSkillData(userId);
            }

            // å…³é—­æŠ€èƒ½å¼¹çª—
            function closeSkillModal() {
                const modal = document.getElementById('skillModal');
                modal.style.display = 'none';

                // é”€æ¯å›¾è¡¨å®ä¾‹
                if (skillChart1) {
                    skillChart1.dispose();
                    skillChart1 = null;
                }
                if (skillChart2) {
                    skillChart2.dispose();
                    skillChart2 = null;
                }
            }

            // ç‰ˆæœ¬æ£€æŸ¥ç›¸å…³å‡½æ•°
            async function checkForUpdates() {
                const now = Date.now();
                const lastCheck = localStorage.getItem('lastUpdateCheck');

                if (lastCheck && now - parseInt(lastCheck) < UPDATE_CHECK_INTERVAL) {
                    return;
                }

                try {
                    console.log('æ£€æŸ¥ç‰ˆæœ¬æ›´æ–°...');

                    // ä»GitHub APIè·å–æœ€æ–°releaseä¿¡æ¯
                    const response = await fetch(`https://api.github.com/repos/${GITHUB_REPO}/releases/latest`, {
                        headers: {
                            Accept: 'application/vnd.github.v3+json',
                        },
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const data = await response.json();
                    const latestVersion = data.tag_name;

                    console.log(`å½“å‰ç‰ˆæœ¬: ${CURRENT_VERSION}, æœ€æ–°ç‰ˆæœ¬: ${latestVersion}`);

                    localStorage.setItem('lastUpdateCheck', now.toString());

                    if (isNewerVersion(latestVersion, CURRENT_VERSION)) {
                        console.log('å‘ç°æ–°ç‰ˆæœ¬ï¼');
                        showUpdateModal(latestVersion, data.html_url);
                    } else {
                        console.log('å½“å‰å·²æ˜¯æœ€æ–°ç‰ˆæœ¬');
                    }
                } catch (error) {
                    console.warn('æ£€æŸ¥ç‰ˆæœ¬æ›´æ–°å¤±è´¥:', error);
                }
            }

            function isNewerVersion(latest, current) {
                const latestClean = latest.replace(/^[vV]/, '');
                const currentClean = current.replace(/^[vV]/, '');
                return latestClean !== currentClean;
            }

            // æ˜¾ç¤ºç‰ˆæœ¬æ›´æ–°å¼¹çª—
            function showUpdateModal(latestVersion, downloadUrl) {
                const modal = document.getElementById('updateModal');
                const currentVersionElement = document.getElementById('currentVersionText');
                const latestVersionElement = document.getElementById('latestVersionText');
                const downloadLink = document.getElementById('downloadLink');

                currentVersionElement.textContent = `V${CURRENT_VERSION}`;
                latestVersionElement.textContent =
                    latestVersion.startsWith('v') || latestVersion.startsWith('V') ? latestVersion : `V${latestVersion}`;

                downloadLink.href = downloadUrl;
                modal.style.display = 'block';

                modal.onclick = function (event) {
                    if (event.target === modal) {
                        closeUpdateModal();
                    }
                };
            }

            // å…³é—­ç‰ˆæœ¬æ›´æ–°å¼¹çª—
            function closeUpdateModal() {
                const modal = document.getElementById('updateModal');
                modal.style.display = 'none';
                modal.onclick = null;
            }

            // è®¾ç½®å¼¹çª—ç›¸å…³é€»è¾‘
            function toggleSettingsModal() {
                const modal = document.getElementById('settingsModal');
                modal.style.display = modal.style.display === 'block' ? 'none' : 'block';
                if (modal.style.display === 'block') {
                    fetch('/api/settings')
                        .then((res) => res.json())
                        .then((json) => {
                            if (json.code === 0 && json.data) {
                                document.getElementById('settingAutoClearOnServerChange').checked = !!json.data.autoClearOnServerChange;
                                document.getElementById('settingAutoClearOnTimeout').checked = !!json.data.autoClearOnTimeout;
                                document.getElementById('settingOnlyRecordEliteDummy').checked = !!json.data.onlyRecordEliteDummy;
                            }
                        })
                        .catch((error) => {
                            console.error('è·å–è®¾ç½®å¤±è´¥:', error);
                            document.getElementById('settingAutoClearOnServerChange').checked = true;
                            document.getElementById('settingAutoClearOnTimeout').checked = false;
                            document.getElementById('settingOnlyRecordEliteDummy').checked = false;
                        });
                }
            }

            function saveSettings() {
                const settings = {
                    autoClearOnServerChange: document.getElementById('settingAutoClearOnServerChange').checked,
                    autoClearOnTimeout: document.getElementById('settingAutoClearOnTimeout').checked,
                    onlyRecordEliteDummy: document.getElementById('settingOnlyRecordEliteDummy').checked,
                };
                fetch('/api/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings),
                })
                    .then((res) => res.json())
                    .then((json) => {
                        if (json.code === 0) {
                            toggleSettingsModal();
                        }
                    });
            }

            // è·å–æŠ€èƒ½æ•°æ®
            async function fetchSkillData(userId) {
                try {
                    const response = await fetch(`/api/skill/${userId}`);
                    const data = await response.json();

                    if (data.code === 0) {
                        renderSkillData(data.data);
                    } else {
                        console.error('è·å–æŠ€èƒ½æ•°æ®å¤±è´¥:', data.msg);
                    }
                } catch (error) {
                    console.error('è·å–æŠ€èƒ½æ•°æ®å¤±è´¥:', error);
                }
            }

            // æ¸²æŸ“æŠ€èƒ½æ•°æ®
            function renderSkillData(skillData) {
                const userInfo = getUserFromArray(skillData.uid);

                // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
                document.getElementById('skillUserId').textContent = skillData.uid;
                document.getElementById('skillUserName').textContent = `${skillData.name || `UID:${skillData.uid}`} - æŠ€èƒ½åˆ†æ`;
                document.getElementById('skillUserNickname').textContent = skillData.name;
                document.getElementById('skillUserProfession').textContent = userInfo ? userInfo.profession || 'æœªçŸ¥' : 'æœªçŸ¥';
                document.getElementById('fightPoint').textContent = userInfo ? userInfo.fightPoint || 'æœªçŸ¥' : 'æœªçŸ¥';
                document.getElementById('maxHp').textContent = skillData.attr ? skillData.attr.max_hp || 'æœªçŸ¥' : 'æœªçŸ¥';
                document.getElementById('skillCount').textContent = Object.keys(skillData.skills).length;

                // æŠŠå¯¹è±¡è½¬æ•°ç»„å¹¶æ’åº
                const skills = Object.entries(skillData.skills);
                const sortedSkills = skills.slice().sort(([, a], [, b]) => b.totalDamage - a.totalDamage);

                // ä¸ºå›¾è¡¨å‡†å¤‡ä¸‰ç»„æ•°æ®
                const skillNames = []; // ç”¨æ¥å­˜ displayName
                const damages = [];
                const critRates = [];
                const luckyRates = [];

                // æ¸²æŸ“è¡¨æ ¼
                const tableBody = document.getElementById('skillTableBody');
                tableBody.innerHTML = '';

                // æ¸²æŸ“è¡¨æ ¼ + æ”¶é›†å›¾è¡¨æ•°æ®
                sortedSkills.forEach(([skillId, skill]) => {
                    const name = skill.displayName || skillId;

                    // å¡«è¡¨æ ¼
                    const row = document.createElement('tr');
                    row.innerHTML = `
                    <td>${name}</td>
                    <td>${skill.type}</td>
                    <td>${skill.elementype}</td>
                    <td>${skill.totalDamage.toLocaleString()}</td>
                    <td>${skill.totalCount}</td>
                    <td class="skill-crit">${(skill.critRate * 100).toFixed(2)}%</td>
                    <td class="skill-lucky">${(skill.luckyRate * 100).toFixed(2)}%</td>
                    <td>${(skill.damageBreakdown.critical + skill.damageBreakdown.crit_lucky).toLocaleString()}</td>
                    <td>${(skill.damageBreakdown.normal + skill.damageBreakdown.lucky).toLocaleString()}</td>
                `;
                    tableBody.appendChild(row);

                    // æ”¶é›†ç»™å›¾è¡¨çš„æ•°æ®
                    skillNames.push(name);
                    damages.push(skill.totalDamage);
                    critRates.push(skill.critRate * 100);
                    luckyRates.push(skill.luckyRate * 100);
                });

                renderSkillCharts(skillNames, damages, critRates, luckyRates);
            }

            // æ¸²æŸ“æŠ€èƒ½å›¾è¡¨
            function renderSkillCharts(skillIds, damages, critRates, luckyRates) {
                const topNames = skillIds.slice(0, 5);
                const topDamages = damages.slice(0, 5);
                const topAllDamages = topDamages.reduce((a, b) => a + b, 0);
                const allDamages = damages.reduce((a, b) => a + b, 0);
                const otherDamages = allDamages - topAllDamages;

                // æ„é€ å‰ 5 çš„ dataï¼Œå¹¶ä¸”éƒ½æ˜¾ç¤ºæ ‡ç­¾
                const pieData = topNames.map((name, idx) => ({
                    value: topDamages[idx],
                    name: name,
                    label: {
                        show: true, // æ‰“å¼€è¿™ä¸€é¡¹çš„æ ‡ç­¾
                        position: 'outside', // æ”¾åˆ°æ‰‡åŒºå¤–ä¾§
                        formatter: '{b}\n{d}%', // æ˜¾ç¤ºâ€œåç§° + ç™¾åˆ†æ¯”â€
                    },
                    labelLine: {
                        show: true, // æ˜¾ç¤ºå¼•å¯¼çº¿
                    },
                }));
                pieData.push({
                    value: otherDamages,
                    name: 'å…¶ä»–',
                    label: {
                        show: true, // æ‰“å¼€è¿™ä¸€é¡¹çš„æ ‡ç­¾
                        position: 'outside', // æ”¾åˆ°æ‰‡åŒºå¤–ä¾§
                        formatter: '{b}\n{d}%', // æ˜¾ç¤ºâ€œåç§° + ç™¾åˆ†æ¯”â€
                    },
                    labelLine: {
                        show: true, // æ˜¾ç¤ºå¼•å¯¼çº¿
                    },
                });

                // é”€æ¯ç°æœ‰å›¾è¡¨
                if (skillChart1) skillChart1.dispose();
                if (skillChart2) skillChart2.dispose();

                // åˆ›å»ºæ–°çš„å›¾è¡¨å®ä¾‹
                skillChart1 = echarts.init(document.getElementById('skillDamageChart'));
                skillChart2 = echarts.init(document.getElementById('skillCritChart'));

                // æŠ€èƒ½æ•°å€¼åˆ†å¸ƒå›¾
                const damageOption = {
                    title: {
                        text: 'æŠ€èƒ½æ•°å€¼åˆ†å¸ƒ',
                        left: 'center',
                        textStyle: { color: '#e2e8f0' },
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: '{b}: {c} ({d}%)',
                        backgroundColor: 'rgba(40, 40, 60, 0.9)',
                        borderColor: '#3498db',
                        textStyle: { color: '#ecf0f1' },
                    },
                    legend: {
                        orient: 'vertical',
                        right: 10,
                        top: 'center',
                        textStyle: { color: '#cbd5e0' },
                    },
                    series: [
                        {
                            name: 'æŠ€èƒ½æ•°å€¼',
                            type: 'pie',
                            radius: ['40%', '70%'],
                            avoidLabelOverlap: false,
                            itemStyle: {
                                borderRadius: 10,
                                borderColor: '#1a2a6c',
                                borderWidth: 2,
                            },
                            label: {
                                show: false,
                                position: 'center',
                            },
                            emphasis: {
                                label: {
                                    show: true,
                                    fontSize: '16',
                                    fontWeight: 'bold',
                                    color: '#e2e8f0',
                                },
                            },
                            labelLine: {
                                show: false,
                            },
                            data: pieData,
                        },
                    ],
                };

                // æš´å‡»ç‡/å¹¸è¿è§¦å‘ç‡å¯¹æ¯”å›¾
                const critOption = {
                    title: {
                        text: 'æš´å‡»ç‡ä¸å¹¸è¿è§¦å‘ç‡',
                        left: 'center',
                        textStyle: { color: '#e2e8f0' },
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: { type: 'shadow' },
                        backgroundColor: 'rgba(40, 40, 60, 0.9)',
                        borderColor: '#3498db',
                        textStyle: { color: '#ecf0f1' },
                    },
                    legend: {
                        data: ['æš´å‡»ç‡', 'å¹¸è¿è§¦å‘ç‡'],
                        bottom: 10,
                        textStyle: { color: '#cbd5e0' },
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        top: '15%',
                        containLabel: true,
                    },
                    xAxis: {
                        type: 'category',
                        data: skillIds.map((id) => `${id}`), //å›¾è¡¨æŠ€èƒ½å
                        axisLine: { lineStyle: { color: '#7f8c8d' } },
                        axisLabel: {
                            color: '#95a5a6',
                            interval: 0,
                            rotate: 45,
                        },
                    },
                    yAxis: {
                        type: 'value',
                        name: 'ç™¾åˆ†æ¯”',
                        min: 0,
                        max: 100,
                        axisLine: { lineStyle: { color: '#7f8c8d' } },
                        axisLabel: { color: '#95a5a6' },
                        splitLine: { lineStyle: { color: 'rgba(127, 140, 141, 0.2)' } },
                    },
                    series: [
                        {
                            name: 'æš´å‡»ç‡',
                            type: 'bar',
                            data: critRates,
                            itemStyle: { color: '#ff9966' },
                        },
                        {
                            name: 'å¹¸è¿è§¦å‘ç‡',
                            type: 'bar',
                            data: luckyRates,
                            itemStyle: { color: '#93f9b9' },
                        },
                    ],
                };

                skillChart1.setOption(damageOption);
                skillChart2.setOption(critOption);

                // å“åº”çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', function () {
                    skillChart1.resize();
                    skillChart2.resize();
                });
            }

            // å¤šç”¨æˆ·æ€§èƒ½ä¼˜åŒ–é…ç½®
            const CHART_CONFIG = {
                MAX_VISIBLE_USERS: 20, // æœ€å¤šåŒæ—¶æ˜¾ç¤ºçš„ç”¨æˆ·æ•°
                PERFORMANCE_MODE_THRESHOLD: 15, // è¶…è¿‡æ­¤æ•°é‡å¯ç”¨æ€§èƒ½æ¨¡å¼
                UPDATE_INTERVAL_NORMAL: 33, // æ­£å¸¸æ¨¡å¼æ›´æ–°é—´éš”(30fps)
                UPDATE_INTERVAL_PERFORMANCE: 100, // æ€§èƒ½æ¨¡å¼æ›´æ–°é—´éš”(10fps)
                DATA_POINT_LIMIT: 300, // æ€§èƒ½æ¨¡å¼ä¸‹çš„æ•°æ®ç‚¹é™åˆ¶(30ç§’)
            };

            let performanceMode = false;
            let userPriorityCache = {}; // ç”¨æˆ·ä¼˜å…ˆçº§ç¼“å­˜

            // ä¼˜åŒ–çš„20è‰²é…è‰²æ–¹æ¡ˆ
            const PALETTE_DARK_20 = [
                '#FF6B6B',
                '#4ECDC4',
                '#45B7D1',
                '#96CEB4',
                '#FFEAA7',
                '#DDA0DD',
                '#FF9F43',
                '#54A0FF',
                '#5F27CD',
                '#00D2D3',
                '#10AC84',
                '#EE5A24',
                '#0984E3',
                '#6C5CE7',
                '#FD79A8',
                '#FF7675',
                '#74B9FF',
                '#A29BFE',
                '#00B894',
                '#FDCB6E',
            ]; // é«˜é¥±å’Œåº¦ç‰ˆæœ¬ï¼Œæ·±è‰²èƒŒæ™¯ä¸‹åŒºåˆ†åº¦æ›´é«˜

            const PALETTE_LIGHT_20 = [
                '#E74C3C',
                '#3498DB',
                '#2ECC71',
                '#F39C12',
                '#9B59B6',
                '#1ABC9C',
                '#E67E22',
                '#34495E',
                '#F1C40F',
                '#E91E63',
                '#8E44AD',
                '#16A085',
                '#27AE60',
                '#F39800',
                '#D35400',
                '#C0392B',
                '#2980B9',
                '#17A2B8',
                '#28A745',
                '#6F42C1',
            ]; // å¼ºå¯¹æ¯”ç‰ˆæœ¬ï¼Œæµ…è‰²èƒŒæ™¯ä¸‹æ¸…æ™°æ˜“è¾¨

            function pickPalette() {
                return document.body.classList.contains('dark-mode') ? PALETTE_DARK_20 : PALETTE_LIGHT_20;
            }

            // ä¸ºç”¨æˆ·åˆ†é…å›ºå®šé¢œè‰²
            function getUserColor(userId) {
                const palette = pickPalette();
                const userIdStr = String(userId);

                if (!userColorMap[userIdStr]) {
                    // åŸºäºç”¨æˆ·IDçš„å“ˆå¸Œå€¼åˆ†é…é¢œè‰²ï¼Œç¡®ä¿åŒä¸€ä¸ªç”¨æˆ·æ€»æ˜¯å¾—åˆ°ç›¸åŒçš„é¢œè‰²
                    let hash = 0;
                    for (let i = 0; i < userIdStr.length; i++) {
                        hash = (hash << 5) - hash + userIdStr.charCodeAt(i);
                        hash |= 0;
                    }
                    const idx = Math.abs(hash) % palette.length;
                    userColorMap[userIdStr] = palette[idx];
                }
                return userColorMap[userIdStr];
            }

            // æœåŠ¡å™¨çŠ¶æ€æç¤ºç®¡ç†
            function showServerStatus(status, message, autoHide = true) {
                const statusElement = document.getElementById('serverStatus');
                const textElement = document.getElementById('serverStatusText');

                if (!statusElement || !textElement) return;

                // æ¸…é™¤ä¹‹å‰çš„è‡ªåŠ¨éšè—å®šæ—¶å™¨
                if (serverStatusTimeout) {
                    clearTimeout(serverStatusTimeout);
                    serverStatusTimeout = null;
                }

                // æ›´æ–°çŠ¶æ€æ ·å¼
                statusElement.className = 'server-status show ' + status;
                textElement.textContent = message;

                // è‡ªåŠ¨éšè—ï¼ˆè¿æ¥æˆåŠŸçŠ¶æ€3ç§’åéšè—ï¼Œå…¶ä»–çŠ¶æ€ä¸è‡ªåŠ¨éšè—ï¼‰
                if (autoHide && status === 'connected') {
                    serverStatusTimeout = setTimeout(() => {
                        hideServerStatus();
                    }, 3000);
                }
            }

            function hideServerStatus() {
                const statusElement = document.getElementById('serverStatus');
                if (statusElement) {
                    statusElement.classList.remove('show');
                }
                if (serverStatusTimeout) {
                    clearTimeout(serverStatusTimeout);
                    serverStatusTimeout = null;
                }
            }

            // ç”¨æˆ·ä¼˜å…ˆçº§è®¡ç®— - åŸºäºDPSå’Œæ´»è·ƒåº¦
            function calculateUserPriority(userId, userArray) {
                const user = userArray.find((u) => u.id.toString() === userId);
                if (!user) return 0;

                const dpsScore = user.realtime_dps_max || 0;
                const totalDamageScore = (user.total_damage?.total || 0) / 100000; // å½’ä¸€åŒ–
                const activityScore = dpsHistory[userId] ? dpsHistory[userId].filter((p) => p.dps > 0).length : 0;

                // æ‰‹åŠ¨è®¾ç½®æ˜µç§°çš„ç”¨æˆ·ä¼˜å…ˆçº§æ›´é«˜
                const nicknameBonus = userNicknames[userId] ? 1000 : 0;

                return dpsScore + totalDamageScore + activityScore + nicknameBonus;
            }

            // è·å–ä¼˜å…ˆæ˜¾ç¤ºçš„ç”¨æˆ·åˆ—è¡¨
            function getTopPriorityUsers(userArray, maxCount) {
                const userIds = Object.keys(dpsHistory).filter(
                    (userId) => visibleUsers[userId] !== false && dpsHistory[userId] && dpsHistory[userId].length > 0,
                );

                // è®¡ç®—å¹¶ç¼“å­˜ä¼˜å…ˆçº§
                userIds.forEach((userId) => {
                    userPriorityCache[userId] = calculateUserPriority(userId, userArray);
                });

                // æŒ‰ä¼˜å…ˆçº§æ’åºå¹¶é™åˆ¶æ•°é‡
                return userIds.sort((a, b) => userPriorityCache[b] - userPriorityCache[a]).slice(0, maxCount);
            }

            // WebSocketè¿æ¥åˆå§‹åŒ–
            function initWebSocket() {
                try {
                    showServerStatus('reconnecting', 'ğŸ”„ æ­£åœ¨è¿æ¥æœåŠ¡å™¨...', false);
                    socket = io();

                    socket.on('connect', () => {
                        console.log('WebSocketè¿æ¥æˆåŠŸ');
                        isWebSocketConnected = true;
                        lastWebSocketMessage = Date.now();
                        webSocketReconnectAttempts = 0;
                        showServerStatus('connected', 'âœ… æœåŠ¡å™¨è¿æ¥æˆåŠŸ');

                        // å¦‚æœä¹‹å‰å¯ç”¨äº†APIå¤‡ç”¨ï¼Œç°åœ¨åˆ‡æ¢å›WebSocket
                        if (fallbackToAPI) {
                            console.log('WebSocketé‡è¿æˆåŠŸï¼Œä»APIæ¨¡å¼åˆ‡æ¢å›WebSocketæ¨¡å¼');
                            fallbackToAPI = false;
                            stopAPIFallback();
                        }
                    });

                    socket.on('disconnect', () => {
                        console.log('WebSocketè¿æ¥æ–­å¼€');
                        isWebSocketConnected = false;
                        webSocketReconnectAttempts++;
                        if (!fallbackToAPI) showServerStatus('disconnected', 'âŒ æœåŠ¡å™¨è¿æ¥æ–­å¼€', false);
                    });

                    socket.on('data', (data) => {
                        lastWebSocketMessage = Date.now();
                        // æš‚åœæ—¶ä¸å¤„ç†æ•°æ®æ›´æ–°
                        if (!isPaused) {
                            processDataUpdate(data);
                        }
                    });

                    socket.on('connect_error', (error) => {
                        console.error('WebSocketè¿æ¥é”™è¯¯:', error);
                        isWebSocketConnected = false;
                        if (!fallbackToAPI) showServerStatus('disconnected', 'âŒ æœåŠ¡å™¨è¿æ¥å¤±è´¥', false);
                    });
                } catch (error) {
                    console.error('WebSocketåˆå§‹åŒ–å¤±è´¥:', error);
                    showServerStatus('disconnected', 'âŒ WebSocketåˆå§‹åŒ–å¤±è´¥', false);
                    startAPIFallback();
                }
            }

            // ç›‘æ§WebSocketè¿æ¥çŠ¶æ€ï¼Œ5ç§’æ— æ¶ˆæ¯åˆ™åˆ‡æ¢åˆ°API
            function monitorWebSocketConnection() {
                setInterval(() => {
                    // æš‚åœæ—¶ä¸è¿›è¡Œè¿æ¥ç›‘æ§
                    if (isPaused) return;

                    const timeSinceLastMessage = Date.now() - lastWebSocketMessage;

                    if (timeSinceLastMessage > 5000 && !fallbackToAPI) {
                        console.warn('WebSocketè¶…è¿‡5ç§’æ— æ¶ˆæ¯ï¼Œåˆ‡æ¢åˆ°APIè½®è¯¢æ¨¡å¼');
                        fallbackToAPI = true;
                        showServerStatus('api-mode', 'ğŸ“¡ åˆ‡æ¢åˆ°APIè½®è¯¢æ¨¡å¼', false);
                        startAPIFallback();
                    }
                }, 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
            }

            // å¯åŠ¨APIå¤‡ç”¨æ¨¡å¼
            function startAPIFallback() {
                if (apiInterval) return; // é¿å…é‡å¤å¯åŠ¨

                console.log('å¯åŠ¨APIè½®è¯¢å¤‡ç”¨æ¨¡å¼');
                showServerStatus('api-mode', 'ğŸ“¡ ä½¿ç”¨APIè½®è¯¢æ¨¡å¼', false);
                apiInterval = setInterval(fetchData, 100);
            }

            // åœæ­¢APIå¤‡ç”¨æ¨¡å¼
            function stopAPIFallback() {
                if (apiInterval) {
                    clearInterval(apiInterval);
                    apiInterval = null;
                    console.log('åœæ­¢APIè½®è¯¢å¤‡ç”¨æ¨¡å¼');
                }
            }

            // è·å–ç”¨æˆ·æ•°æ®çš„è¾…åŠ©å‡½æ•°
            function getUserFromArray(userId) {
                return currentUserArray.find((user) => user.id.toString() === userId.toString());
            }

            // åˆ¤æ–­è§’è‰²æ˜¯å¦æœªå‚ä¸æˆ˜æ–—
            function isUserInactive(user) {
                // æ£€æŸ¥æ€»ä¼¤å®³ã€æ€»DPSã€æ€»HPSæ˜¯å¦éƒ½ä¸º0
                const totalDamage = user.total_damage?.total || 0;
                const totalDps = user.total_dps || 0;
                const totalHps = user.total_hps || 0;

                // æ£€æŸ¥æš´å‡»ç‡å’Œå¹¸è¿ç‡æ˜¯å¦ä¸ºNaN
                const critRate = user.total_count?.critical / user.total_count?.total;
                const luckyRate = user.total_count?.lucky / user.total_count?.total;

                return (totalDamage === 0 && totalDps === 0 && totalHps === 0) || (isNaN(critRate) && isNaN(luckyRate));
            }

            // åˆ‡æ¢éšè—æœªå‚æˆ˜è§’è‰²åŠŸèƒ½
            function toggleHideInactiveUsers() {
                hideInactiveUsers = !hideInactiveUsers;
                const btn = document.getElementById('hideInactiveBtn');
                if (hideInactiveUsers) {
                    btn.classList.add('active');
                    btn.innerHTML = 'ğŸ‘€ å·²éšè—æœªå‚æˆ˜';
                } else {
                    btn.classList.remove('active');
                    btn.innerHTML = 'ğŸ‘€ éšè—æœªå‚æˆ˜';
                }

                // é‡æ–°å¤„ç†å½“å‰æ•°æ®
                if (currentUserArray && currentUserArray.length > 0) {
                    // é‡æ–°è¿‡æ»¤å¹¶æ›´æ–°è¡¨æ ¼
                    sortUserArray(currentUserArray);
                    let visibleUserArray = currentUserArray.filter((user) => visibleUsers[user.id] !== false);

                    // å¦‚æœå¯ç”¨äº†éšè—æœªå‚æˆ˜è§’è‰²ï¼Œè¿›ä¸€æ­¥è¿‡æ»¤
                    if (hideInactiveUsers) {
                        visibleUserArray = visibleUserArray.filter((user) => !isUserInactive(user));
                    }

                    lastVisiableUserArray = visibleUserArray;
                    updateTables(visibleUserArray);
                }
            }

            // å¤„ç†æ•°æ®æ›´æ–°ï¼ˆWebSocketå’ŒAPIé€šç”¨ï¼‰
            function processDataUpdate(data, updateHistory = true) {
                try {
                    // å°†æ•°æ®è½¬æ¢ä¸ºæ•°ç»„ä»¥ä¾¿æ’åº
                    const userArray = Object.keys(data.user).map((id) => ({
                        id: Number(id),
                        ...data.user[id],
                    }));

                    // ç¼“å­˜å½“å‰ç”¨æˆ·æ•°ç»„
                    currentUserArray = userArray;

                    // æ›´æ–°DPSå†å²æ•°æ®
                    if (updateHistory) {
                        updateDpsHistory(userArray);
                    }

                    // æ›´æ–°ç”¨æˆ·æ§åˆ¶åˆ—è¡¨
                    updateUserControlsList(userArray);

                    // æ ¹æ®å½“å‰æ’åºæ¨¡å¼æ’åº
                    sortUserArray(userArray);

                    // è¿‡æ»¤ä¸å¯è§çš„ç”¨æˆ·
                    let visibleUserArray = userArray.filter((user) => visibleUsers[user.id] !== false);

                    // å¦‚æœå¯ç”¨äº†éšè—æœªå‚æˆ˜è§’è‰²ï¼Œè¿›ä¸€æ­¥è¿‡æ»¤
                    if (hideInactiveUsers) {
                        visibleUserArray = visibleUserArray.filter((user) => !isUserInactive(user));
                    }

                    lastVisiableUserArray = visibleUserArray;
                    updateTables(visibleUserArray);

                    // æ£€æŸ¥æ˜¯å¦éœ€è¦å¯ç”¨æ€§èƒ½æ¨¡å¼
                    const activeUserCount = Object.keys(dpsHistory).length;
                    const shouldEnablePerformanceMode = activeUserCount > CHART_CONFIG.PERFORMANCE_MODE_THRESHOLD;

                    if (shouldEnablePerformanceMode !== performanceMode) {
                        performanceMode = shouldEnablePerformanceMode;
                        console.log(`${performanceMode ? 'å¯ç”¨' : 'å…³é—­'}æ€§èƒ½æ¨¡å¼ (ç”¨æˆ·æ•°: ${activeUserCount})`);
                    }

                    // æ›´æ–°å›¾è¡¨
                    if (updateHistory) {
                        updateChart(userArray);
                    }
                } catch (err) {
                    console.error('å¤„ç†æ•°æ®æ›´æ–°å¤±è´¥ï¼š', err);
                }
            }

            // ç”Ÿæˆè¡¨æ ¼è¡Œ
            function updateTables(visibleUserArray) {
                const damageTable = document.getElementById('damageTable').querySelector('tbody');
                //è·å–damageTableé‡Œçš„æ‰€æœ‰è¡Œ
                let existingRows = damageTable.querySelectorAll('tr');
                if (existingRows.length > visibleUserArray.length) {
                    // ç§»é™¤å¤šä½™çš„è¡Œ
                    for (let i = existingRows.length - 1; i >= visibleUserArray.length; i--) {
                        damageTable.removeChild(existingRows[i]);
                    }
                }
                if (existingRows.length < visibleUserArray.length) {
                    // æ·»åŠ æ–°è¡Œ
                    for (let i = existingRows.length; i < visibleUserArray.length; i++) {
                        const row = document.createElement('tr');
                        damageTable.appendChild(row);
                    }
                }
                existingRows = damageTable.querySelectorAll('tr');

                for (let i = 0; i < visibleUserArray.length; i++) {
                    const user = visibleUserArray[i];
                    const crit_rate = user.total_count.critical / user.total_count.total;
                    const lucky_rate = user.total_count.lucky / user.total_count.total;

                    const row = existingRows[i];

                    const isSimpleMode = document.body.classList.contains('simple-mode');

                    // å…¶ä»–æ•°æ®åˆ—
                    const otherCells = [
                        user.profession || 'æœªçŸ¥',
                        Number(user.fightPoint).toLocaleString(),
                        (user.hp ?? 'æœªçŸ¥').toLocaleString(),
                        Number(user.taken_damage).toLocaleString(),
                        user.dead_count ?? 'æœªçŸ¥',
                        `${(crit_rate * 100).toFixed(2)}%`,
                        `${(lucky_rate * 100).toFixed(2)}%`,
                    ];
                    if (currentDataGroup === 'damage' || currentDataGroup === 'all') {
                        otherCells.push(Number(user.total_damage.total).toLocaleString());
                        if (!isSimpleMode) {
                            otherCells.push(
                                Number(user.total_damage.critical).toLocaleString(),
                                Number(user.total_damage.lucky).toLocaleString(),
                                Number(user.total_damage.crit_lucky).toLocaleString(),
                            );
                        }
                        otherCells.push(
                            Number(user.realtime_dps).toLocaleString(),
                            Number(user.realtime_dps_max).toLocaleString(),
                            Number(user.total_dps.toFixed(2)).toLocaleString(),
                        );
                    }
                    if (currentDataGroup === 'healing' || currentDataGroup === 'all') {
                        otherCells.push(Number(user.total_healing.total).toLocaleString());
                        if (!isSimpleMode) {
                            otherCells.push(
                                Number(user.total_healing.critical).toLocaleString(),
                                Number(user.total_healing.lucky).toLocaleString(),
                                Number(user.total_healing.crit_lucky).toLocaleString(),
                            );
                        }
                        otherCells.push(
                            Number(user.realtime_hps).toLocaleString(),
                            Number(user.realtime_hps_max).toLocaleString(),
                            Number(user.total_hps.toFixed(2)).toLocaleString(),
                        );
                    }
                    let existingCells = row.querySelectorAll('td');
                    //æ‰€éœ€å±•ç¤ºçš„åˆ—æ•°
                    const requiredColumnCount = 3 + otherCells.length;
                    if (existingCells.length > requiredColumnCount) {
                        // ç§»é™¤å¤šä½™çš„å•å…ƒæ ¼
                        for (let j = existingCells.length - 1; j >= requiredColumnCount; j--) {
                            row.removeChild(existingCells[j]);
                        }
                    }
                    if (existingCells.length < requiredColumnCount) {
                        // æ·»åŠ æ–°å•å…ƒæ ¼
                        for (let j = existingCells.length; j < requiredColumnCount; j++) {
                            const cell = document.createElement('td');
                            row.appendChild(cell);
                        }
                    }
                    existingCells = row.querySelectorAll('td');
                    // æ›´æ–°å•å…ƒæ ¼å†…å®¹
                    existingCells.forEach((cell, index) => {
                        if (index < 2) return;
                        if (otherCells[index - 2] !== undefined) {
                            cell.textContent = otherCells[index - 2];
                        }
                    });

                    // è§’è‰²IDåˆ—
                    const uidCell = existingCells[0];
                    uidCell.textContent = `${user.id}`;

                    // è§’è‰²æ˜µç§°åˆ—
                    const nicknameCell = existingCells[1];
                    // Check if user.name is a non-empty string
                    const hasValidName = user.name && user.name.trim() !== '';
                    const nickname = userNicknames[user.id] || (hasValidName ? user.name : '');

                    nicknameCell.textContent = nickname;
                    const operationCell = existingCells[existingCells.length - 1];
                    if (operationCell.querySelector('.skill-btn')) {
                        // å¦‚æœå·²ç»å­˜åœ¨æŠ€èƒ½æŒ‰é’®ï¼Œåˆ™åªæ›´æ–°ç”¨æˆ·ID
                        operationCell.querySelector('.skill-btn').setAttribute('data-user-id', user.id);
                        operationCell.querySelector('.copy-btn').setAttribute('data-user-id', user.id);
                    } else {
                        operationCell.innerHTML = '';
                        const operationDiv = document.createElement('div');
                        operationDiv.className = 'operation-div';
                        operationCell.appendChild(operationDiv);

                        // åˆ›å»ºå¤åˆ¶æŒ‰é’®
                        const copyButton = document.createElement('button');
                        copyButton.className = 'copy-btn';
                        copyButton.innerHTML = '<i class="icon">ğŸ“‹</i> å¤åˆ¶æ•°æ®';
                        copyButton.setAttribute('data-user-id', user.id);
                        operationDiv.appendChild(copyButton);

                        // åˆ›å»ºæŠ€èƒ½æŒ‰é’®
                        const skillButton = document.createElement('button');
                        skillButton.className = 'skill-btn';
                        skillButton.innerHTML = '<i class="icon">ğŸ“Š</i> æŠ€èƒ½åˆ†æ';
                        skillButton.setAttribute('data-user-id', user.id);
                        operationDiv.appendChild(skillButton);
                    }
                }
                updateTableStickyHeader();
                // åº”ç”¨åˆ—æ˜¾ç¤ºè®¾ç½®
                if (typeof applyColumnVisibility === 'function') {
                    applyColumnVisibility();
                }
            }

            async function fetchData() {
                // æš‚åœæ—¶ä¸è·å–æ•°æ®
                if (isPaused) return;

                try {
                    const res = await fetch('/api/data');
                    if (!res.ok) {
                        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    }
                    const data = await res.json();
                    processDataUpdate(data);

                    // APIè¯·æ±‚æˆåŠŸæ—¶ï¼Œå¦‚æœæ˜¾ç¤ºçš„æ˜¯æ–­çº¿çŠ¶æ€ï¼Œæ›´æ–°ä¸ºAPIæ¨¡å¼
                    if (fallbackToAPI) {
                        showServerStatus('api-mode', 'ğŸ“¡ APIè½®è¯¢æ¨¡å¼è¿è¡Œä¸­', false);
                    }
                } catch (err) {
                    console.error('è·å–æ•°æ®å¤±è´¥ï¼š', err);
                    showServerStatus('disconnected', 'âŒ æ— æ³•è·å–æœåŠ¡å™¨æ•°æ®', false);
                }
            }

            function sortUserArray(userArray) {
                switch (currentSortMode) {
                    case 'damage':
                        userArray.sort((a, b) => b.total_damage.total - a.total_damage.total);
                        break;
                    case 'uid':
                        userArray.sort((a, b) => a.id - b.id);
                        break;
                    case 'dps':
                        userArray.sort((a, b) => b.total_dps - a.total_dps);
                        break;
                    case 'realtimeDpsMax':
                        userArray.sort((a, b) => b.realtime_dps_max - a.realtime_dps_max);
                        break;
                    case 'takenDamage':
                        userArray.sort((a, b) => b.taken_damage - a.taken_damage);
                        break;
                    case 'healing':
                        userArray.sort((a, b) => b.total_healing.total - a.total_healing.total);
                        break;
                    case 'hps':
                        userArray.sort((a, b) => b.total_hps - a.total_hps);
                        break;
                    case 'realtimeHpsMax':
                        userArray.sort((a, b) => b.realtime_hps_max - a.realtime_hps_max);
                        break;
                    case 'fightPoint':
                        userArray.sort((a, b) => b.fightPoint - a.fightPoint);
                        break;
                    case 'hp_min':
                        userArray.sort((a, b) => a.hp - b.hp);
                        break;
                    default:
                        userArray.sort((a, b) => a.id - b.id);
                        break;
                }
            }

            function updateSortMode() {
                const select = document.getElementById('sortSelect');
                currentSortMode = select.value;
                localStorage.setItem('sortMode', currentSortMode);
                fetchData();
            }

            async function clearData() {
                const res = await fetch('/api/clear');
                const data = await res.json();

                // æ¸…ç©ºå†å²æ•°æ®å’Œå›¾è¡¨ç¼“å­˜
                dpsHistory = {};
                chartDatasetMap = {};
                userPriorityCache = {};
                userColorMap = {}; // æ¸…ç©ºé¢œè‰²æ˜ å°„
                currentUserArray = []; // æ¸…ç©ºå½“å‰ç”¨æˆ·æ•°ç»„ç¼“å­˜
                lastUpdateTime = 0; // é‡ç½®å›¾è¡¨æ›´æ–°æ—¶é—´
                performanceMode = false;

                // æ¸…ç©ºEChartså›¾è¡¨ - å®Œå…¨é‡æ–°åˆå§‹åŒ–
                if (chart) {
                    // é”€æ¯ç°æœ‰å›¾è¡¨
                    chart.dispose();
                    chart = null;

                    // é‡ç½®å›¾è¡¨åˆå§‹åŒ–çŠ¶æ€
                    chartInitialized = false;

                    // é‡æ–°åˆå§‹åŒ–ç©ºå›¾è¡¨
                    initChart();
                }

                // æ¸…ç©ºæ§åˆ¶é¢æ¿ä¸­çš„ç”¨æˆ·æ§åˆ¶é¡¹
                const userControlsList = document.getElementById('userControlsList');
                if (userControlsList) {
                    userControlsList.innerHTML = '';
                }

                fetchData();
                // æ¸…ç©ºè¡¨æ ¼æ˜¾ç¤º
                const damageTable = document.getElementById('damageTable').querySelector('tbody');
                damageTable.innerHTML = '';

                // å³ä½¿åœ¨æš‚åœçŠ¶æ€ä¸‹ä¹Ÿè¦è·å–æ•°æ®ä»¥æ˜¾ç¤ºæ¸…ç©ºåçš„ç»“æœ
                // ä¸´æ—¶ä¿å­˜æš‚åœçŠ¶æ€
                const wasPaused = isPaused;
                isPaused = false;

                // è·å–å¹¶æ˜¾ç¤ºæ¸…ç©ºåçš„æ•°æ®
                await fetchData();

                // æ¢å¤æš‚åœçŠ¶æ€
                isPaused = wasPaused;
            }

            function toggleDarkMode() {
                const body = document.body;
                const isDarkMode = body.classList.contains('dark-mode');
                const button = event.target;

                if (isDarkMode) {
                    body.classList.remove('dark-mode');
                    button.textContent = 'ğŸŒ™ å¤œé—´æ¨¡å¼';
                    localStorage.setItem('darkMode', 'false');
                } else {
                    body.classList.add('dark-mode');
                    button.textContent = 'â˜€ï¸ æ—¥é—´æ¨¡å¼';
                    localStorage.setItem('darkMode', 'true');
                }
            }

            function toggleSimpleMode() {
                const body = document.body;
                const isSimpleMode = body.classList.contains('simple-mode');
                const button = event.target;

                if (isSimpleMode) {
                    body.classList.remove('simple-mode');
                    button.textContent = 'ğŸ“‹ ç®€æ´æ¨¡å¼';
                    localStorage.setItem('simpleMode', 'false');
                } else {
                    body.classList.add('simple-mode');
                    button.textContent = 'ğŸ“„ è¯¦ç»†æ¨¡å¼';
                    localStorage.setItem('simpleMode', 'true');
                }

                // åˆ‡æ¢æ¨¡å¼åéœ€è¦é‡æ–°åº”ç”¨åˆ—æ˜¾ç¤ºè®¾ç½®
                if (typeof applyColumnVisibility === 'function') {
                    applyColumnVisibility();
                }

                // åœ¨æš‚åœçŠ¶æ€ä¸‹ï¼Œåˆ‡æ¢æ¨¡å¼åéœ€è¦é‡æ–°æ¸²æŸ“è¡¨æ ¼
                if (isPaused && lastVisiableUserArray.length > 0) {
                    updateTables(lastVisiableUserArray);
                }
            }

            // æ‰“å¼€è¡€æ¡ç›‘æ§çª—å£
            function openHpWindow() {
                // é¦–å…ˆå°è¯•ç”»ä¸­ç”»æ¨¡å¼
                if ('documentPictureInPicture' in window && window.documentPictureInPicture.requestWindow) {
                    console.log('å°è¯•ä½¿ç”¨ç”»ä¸­ç”»æ¨¡å¼æ‰“å¼€è¡€æ¡ç›‘æ§');

                    window.documentPictureInPicture
                        .requestWindow({
                            width: 900,
                            height: 600,
                            disallowReturnToOpener: true,
                            preferInitialWindowPlacement: true,
                        })
                        .then((pipWindow) => {
                            // åˆ›å»ºåŸºæœ¬çš„HTMLç»“æ„
                            pipWindow.document.write(`
                            <!DOCTYPE html>
                            <html lang="zh-CN">
                            <head>
                                <meta charset="UTF-8">
                                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                                <title>è¡€æ¡ç›‘æ§ - æ˜Ÿç—•å…±é¸£</title>
                                <style>
                                    * {
                                        margin: 0;
                                        padding: 0;
                                        box-sizing: border-box;
                                    }
                                    html, body { 
                                        width: 100%;
                                        height: 100vh;
                                        margin: 0; 
                                        padding: 0; 
                                        overflow: hidden; 
                                        background: #1e3c72;
                                    }
                                    iframe { 
                                        width: 100vw; 
                                        height: 100vh; 
                                        border: none; 
                                        display: block;
                                        position: absolute;
                                        top: 0;
                                        left: 0;
                                    }
                                </style>
                            </head>
                            <body>
                                <iframe src="./hp_window.html" title="è¡€æ¡ç›‘æ§"></iframe>
                            </body>
                            </html>
                        `);
                            pipWindow.document.close();

                            console.log('è¡€æ¡ç›‘æ§çª—å£å·²åœ¨ç”»ä¸­ç”»æ¨¡å¼ä¸‹æ‰“å¼€');
                        })
                        .catch((error) => {
                            console.error('ç”»ä¸­ç”»æ¨¡å¼æ‰“å¼€å¤±è´¥ï¼Œé™çº§åˆ°æ™®é€šçª—å£:', error);
                            openHpWindowFallback();
                        });
                } else {
                    console.log('æµè§ˆå™¨ä¸æ”¯æŒç”»ä¸­ç”»åŠŸèƒ½ï¼Œä½¿ç”¨æ™®é€šçª—å£');
                    alert('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒç”»ä¸­ç”»åŠŸèƒ½ï¼Œå»ºè®®ä½¿ç”¨ Chrome 116 ä»¥ä¸Šç‰ˆæœ¬çš„æµè§ˆå™¨ã€‚');
                    openHpWindowFallback();
                }
            }

            // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨æ™®é€šçª—å£æ‰“å¼€è¡€æ¡ç›‘æ§
            function openHpWindowFallback() {
                try {
                    const hpWindow = window.open(
                        './hp_window.html',
                        'hpWindow',
                        'width=900,height=600,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=no,status=no',
                    );

                    if (hpWindow) {
                        hpWindow.focus();
                        console.log('è¡€æ¡ç›‘æ§çª—å£å·²åœ¨æ™®é€šçª—å£æ¨¡å¼ä¸‹æ‰“å¼€');
                    } else {
                        throw new Error('æ— æ³•æ‰“å¼€æ–°çª—å£ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨å¼¹çª—æ‹¦æˆªè®¾ç½®');
                    }
                } catch (error) {
                    console.error('æ‰“å¼€è¡€æ¡ç›‘æ§çª—å£å¤±è´¥:', error);
                    alert('æ‰“å¼€è¡€æ¡ç›‘æ§çª—å£å¤±è´¥: ' + error.message + '\n\nè¯·æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦é˜»æ­¢äº†å¼¹çª—ã€‚');
                }
            }

            // åˆ‡æ¢æš‚åœ/å¼€å§‹ç»Ÿè®¡
            function togglePause() {
                isPaused = !isPaused;
                const button = document.getElementById('pauseButton');

                if (isPaused) {
                    button.textContent = 'â–¶ï¸ å¼€å§‹ç»Ÿè®¡';
                    console.log('ç»Ÿè®¡å·²æš‚åœ');
                    // æš‚åœæ—¶åœæ­¢APIè½®è¯¢
                    stopAPIFallback();
                } else {
                    button.textContent = 'â¸ï¸ æš‚åœç»Ÿè®¡';
                    console.log('ç»Ÿè®¡å·²å¼€å§‹');
                    // é‡æ–°å¼€å§‹æ—¶ï¼Œå¦‚æœæ˜¯APIæ¨¡å¼åˆ™é‡æ–°å¯åŠ¨
                    if (fallbackToAPI) {
                        startAPIFallback();
                    }
                }

                // ä¿å­˜æš‚åœçŠ¶æ€åˆ°æœ¬åœ°å­˜å‚¨
                localStorage.setItem('isPaused', isPaused.toString());

                // é€šçŸ¥æœåŠ¡å™¨æš‚åœ/å¼€å§‹çŠ¶æ€
                fetch('/api/pause', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ paused: isPaused }),
                }).catch((err) => {
                    console.error('è®¾ç½®æš‚åœçŠ¶æ€å¤±è´¥ï¼š', err);
                });
            }

            // åˆ‡æ¢å›¾è¡¨æ˜¾ç¤º/éšè—
            function toggleChartVisibility() {
                isChartVisible = !isChartVisible;
                const chartContent = document.getElementById('dpsChartContent');
                const toggleBtn = document.getElementById('chartToggleBtn');

                if (isChartVisible) {
                    // å±•å¼€åŠ¨ç”»
                    chartContent.style.height = '350px';
                    chartContent.style.opacity = '1';
                    toggleBtn.classList.remove('collapsed');
                    toggleBtn.title = 'éšè—å›¾è¡¨';

                    // é‡æ–°åˆå§‹åŒ–å›¾è¡¨
                    if (!chart) {
                        // ç­‰å¾…åŠ¨ç”»å®Œæˆåå†åˆå§‹åŒ–å›¾è¡¨
                        setTimeout(() => {
                            initChart();
                            setTimeout(() => {
                                if (chart) chart.resize();
                            }, 350);
                        }, 100);
                    }
                } else {
                    // æŠ˜å åŠ¨ç”»
                    chartContent.style.height = '0px';
                    chartContent.style.opacity = '0';
                    toggleBtn.classList.add('collapsed');
                    toggleBtn.title = 'æ˜¾ç¤ºå›¾è¡¨';
                }

                localStorage.setItem('chartVisible', isChartVisible.toString());
            }

            // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥æœ¬åœ°å­˜å‚¨çš„ä¸»é¢˜åå¥½å’Œæ’åºåå¥½
            function initTheme() {
                const isDarkMode = localStorage.getItem('darkMode') === 'true';
                const body = document.body;
                const button = document.querySelector('button[onclick="toggleDarkMode()"]');

                if (isDarkMode) {
                    body.classList.add('dark-mode');
                    button.textContent = 'â˜€ï¸ æ—¥é—´æ¨¡å¼';
                }
            }

            function initSimpleMode() {
                const isSimpleMode = localStorage.getItem('simpleMode') === 'true';
                const body = document.body;
                const button = document.querySelector('button[onclick="toggleSimpleMode()"]');

                if (isSimpleMode) {
                    body.classList.add('simple-mode');
                    button.textContent = 'ğŸ“„ è¯¦ç»†æ¨¡å¼';
                }
            }

            function initSortMode() {
                const savedSortMode = localStorage.getItem('sortMode');
                if (savedSortMode) {
                    currentSortMode = savedSortMode;
                    document.getElementById('sortSelect').value = savedSortMode;
                }
            }

            // åˆå§‹åŒ–æ•°æ®ç»„æ˜¾ç¤ºæ¨¡å¼
            function initDataGroup() {
                const savedDataGroup = localStorage.getItem('dataGroup') || 'damage';
                currentDataGroup = savedDataGroup;
                setDataGroup(savedDataGroup);
            }

            // åˆ‡æ¢æ•°æ®ç»„æ˜¾ç¤º
            function toggleDataGroup(group) {
                currentDataGroup = group;
                setDataGroup(group);
                localStorage.setItem('dataGroup', group);
                if (isPaused) updateTables(lastVisiableUserArray);
            }

            // è®¾ç½®æ•°æ®ç»„æ˜¾ç¤ºçŠ¶æ€
            function setDataGroup(group) {
                const body = document.body;
                const damageBtn = document.getElementById('damageGroupBtn');
                const healingBtn = document.getElementById('healingGroupBtn');
                const allBtn = document.getElementById('allGroupBtn');

                body.classList.remove('hide-damage', 'hide-healing');
                [damageBtn, healingBtn, allBtn].forEach((btn) => {
                    if (btn) btn.classList.remove('active');
                });

                switch (group) {
                    case 'damage':
                        body.classList.add('hide-healing');
                        if (damageBtn) damageBtn.classList.add('active');
                        break;
                    case 'healing':
                        body.classList.add('hide-damage');
                        if (healingBtn) healingBtn.classList.add('active');
                        break;
                    case 'all':
                        if (allBtn) allBtn.classList.add('active');
                        break;
                    default:
                        // é»˜è®¤æ˜¾ç¤ºä¼¤å®³&DPS
                        body.classList.add('hide-healing');
                        if (damageBtn) damageBtn.classList.add('active');
                        break;
                }
            }

            // åˆå§‹åŒ–å›¾è¡¨å¯è§æ€§çŠ¶æ€
            function initChartVisibility() {
                const savedChartVisible = localStorage.getItem('chartVisible');
                if (savedChartVisible !== null) {
                    isChartVisible = savedChartVisible === 'true';
                }

                const chartContent = document.getElementById('dpsChartContent');
                const toggleBtn = document.getElementById('chartToggleBtn');

                if (!isChartVisible) {
                    chartContent.style.height = '0px';
                    chartContent.style.opacity = '0';
                    toggleBtn.classList.add('collapsed');
                    toggleBtn.title = 'æ˜¾ç¤ºå›¾è¡¨';
                } else {
                    chartContent.style.height = '350px';
                    chartContent.style.opacity = '1';
                    toggleBtn.classList.remove('collapsed');
                    toggleBtn.title = 'éšè—å›¾è¡¨';
                }
            }

            // åˆå§‹åŒ–æš‚åœçŠ¶æ€ - ä¼˜å…ˆä»æœåŠ¡å™¨è·å–çŠ¶æ€
            async function initPauseState() {
                try {
                    // ä»æœåŠ¡å™¨è·å–å½“å‰æš‚åœçŠ¶æ€
                    const response = await fetch('/api/pause');
                    const data = await response.json();
                    isPaused = data.paused;
                } catch (error) {
                    // å¦‚æœæœåŠ¡å™¨è·å–å¤±è´¥ï¼Œä»æœ¬åœ°å­˜å‚¨è·å–
                    console.warn('è·å–æœåŠ¡å™¨æš‚åœçŠ¶æ€å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°å­˜å‚¨çŠ¶æ€');
                    const savedPauseState = localStorage.getItem('isPaused');
                    isPaused = savedPauseState === 'true';
                }

                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                const button = document.getElementById('pauseButton');
                if (isPaused) {
                    button.textContent = 'â–¶ï¸ å¼€å§‹ç»Ÿè®¡';
                } else {
                    button.textContent = 'â¸ï¸ æš‚åœç»Ÿè®¡';
                }
            }

            // DPSå†å²æ•°æ®ç®¡ç† - ä¿æŒæ•°æ®çœŸå®æ€§
            function updateDpsHistory(userArray) {
                const currentTime = Date.now();

                for (const user of userArray) {
                    if (!dpsHistory[user.id]) {
                        dpsHistory[user.id] = [];
                    }

                    // åªè®°å½•çœŸå®çš„DPSæ•°æ®ï¼Œä¸è¿›è¡Œäººå·¥å¹³æ»‘
                    dpsHistory[user.id].push({
                        time: currentTime,
                        dps: user.realtime_dps,
                        isActive: user.realtime_dps > 0, // æ ‡è®°æ˜¯å¦åœ¨æ´»è·ƒè¾“å‡º
                    });

                    // ä¿æŒæœ€å¤š60ç§’çš„æ•°æ®
                    const cutoffTime = currentTime - 60000; // 60ç§’å‰
                    dpsHistory[user.id] = dpsHistory[user.id].filter((point) => point.time > cutoffTime);
                }
            }

            // åˆå§‹åŒ–EChartså›¾è¡¨
            function initChart() {
                if (!isChartVisible) return;

                const chartDom = document.getElementById('dpsChart');
                chart = echarts.init(chartDom);

                const option = {
                    backgroundColor: 'transparent',
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '8%',
                        top: '15%',
                        containLabel: true,
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(50, 50, 50, 0.9)',
                        borderColor: '#777',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12,
                        },
                        axisPointer: {
                            type: 'cross',
                            crossStyle: {
                                color: '#999',
                            },
                        },
                        formatter: function (params) {
                            if (params.length === 0) return '';
                            let result = `<div style="font-weight: bold; margin-bottom: 4px;">æ—¶é—´: ${params[0].name}</div>`;
                            params.forEach((param) => {
                                if (param.value !== null && param.value !== undefined) {
                                    result += `<div style="margin: 2px 0;">
                                    <span style="display: inline-block; width: 10px; height: 10px; background: ${param.color}; border-radius: 50%; margin-right: 6px;"></span>
                                    ${param.seriesName}: <span style="font-weight: bold;">${param.value}</span>
                                </div>`;
                                }
                            });
                            return result;
                        },
                    },
                    legend: {
                        type: 'scroll',
                        orient: 'horizontal',
                        top: 10,
                        textStyle: {
                            fontSize: 12,
                            color: '#666',
                        },
                        pageButtonItemGap: 10,
                        pageButtonPosition: 'end',
                        pageFormatter: '{current}/{total}',
                        pageIconColor: '#666',
                        pageIconInactiveColor: '#ccc',
                        pageTextStyle: {
                            color: '#666',
                            fontSize: 12,
                        },
                    },
                    xAxis: {
                        type: 'category',
                        data: [],
                        axisLine: {
                            lineStyle: {
                                color: '#ddd',
                            },
                        },
                        axisTick: {
                            lineStyle: {
                                color: '#ddd',
                            },
                        },
                        axisLabel: {
                            color: '#666',
                            fontSize: 11,
                            formatter: function (value, index) {
                                return index % 100 === 0 ? `${60 - Math.floor(index / 10)}s` : '';
                            },
                        },
                        splitLine: {
                            show: true,
                            lineStyle: {
                                color: '#f0f0f0',
                                type: 'dashed',
                            },
                        },
                    },
                    yAxis: {
                        type: 'value',
                        name: 'DPS',
                        nameTextStyle: {
                            color: '#666',
                            fontSize: 12,
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#ddd',
                            },
                        },
                        axisTick: {
                            lineStyle: {
                                color: '#ddd',
                            },
                        },
                        axisLabel: {
                            color: '#666',
                            fontSize: 11,
                            formatter: function (value) {
                                if (value >= 1000) {
                                    return (value / 1000).toFixed(1) + 'K';
                                }
                                return value;
                            },
                        },
                        splitLine: {
                            lineStyle: {
                                color: '#f0f0f0',
                                type: 'dashed',
                            },
                        },
                    },
                    series: [],
                };

                chart.setOption(option);

                // ç›‘å¬å›¾ä¾‹çš„é€‰æ‹©å˜åŒ–äº‹ä»¶ï¼ŒåŒæ­¥æ§åˆ¶é¢æ¿å¤é€‰æ¡†çŠ¶æ€
                chart.on('legendselectchanged', function (params) {
                    // é˜²æ­¢ä»æ§åˆ¶é¢æ¿è§¦å‘çš„äº‹ä»¶å†æ¬¡å¤„ç†
                    if (isUpdatingFromLegend) return;

                    const seriesName = params.name;
                    const isSelected = params.selected[seriesName];

                    // æŸ¥æ‰¾å¯¹åº”çš„ç”¨æˆ·ID
                    let userId = null;

                    // æ£€æŸ¥æ˜¯å¦æ˜¯UIDæ ¼å¼çš„æ˜µç§°
                    const uidMatch = seriesName.match(/UID:(\d+)/);
                    if (uidMatch) {
                        userId = uidMatch[1];
                    } else {
                        // æŸ¥æ‰¾è‡ªå®šä¹‰æ˜µç§°å¯¹åº”çš„userId
                        userId = Object.keys(userNicknames).find((id) => userNicknames[id] === seriesName);
                    }

                    if (userId) {
                        const userIdStr = String(userId);

                        // åŒæ­¥visibleUsersçŠ¶æ€
                        if (isSelected) {
                            delete visibleUsers[userIdStr];
                        } else {
                            visibleUsers[userIdStr] = false;
                        }
                        localStorage.setItem('visibleUsers', JSON.stringify(visibleUsers));

                        // åŒæ­¥æ§åˆ¶é¢æ¿å¤é€‰æ¡†çŠ¶æ€
                        const controlElement = document.querySelector(`[data-user-id="${userIdStr}"]`);
                        if (controlElement) {
                            const checkbox = controlElement.querySelector('.visibility-checkbox');
                            if (checkbox) {
                                checkbox.checked = isSelected;
                            }
                        }
                    }
                });

                // å“åº”çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', () => {
                    chart.resize();
                });
            }

            // æ›´æ–°å›¾è¡¨ - å¢é‡æ›´æ–°é¿å…é—ªçƒ
            function updateChart(userArray) {
                if (!isChartVisible) return updateChartStatus(0, Object.keys(dpsHistory).length);
                if (!chart) return;

                const currentTime = Date.now();

                // åŠ¨æ€æ›´æ–°é¢‘ç‡æ§åˆ¶
                const updateInterval = performanceMode ? CHART_CONFIG.UPDATE_INTERVAL_PERFORMANCE : CHART_CONFIG.UPDATE_INTERVAL_NORMAL;

                if (currentTime - lastUpdateTime < updateInterval) return;
                lastUpdateTime = currentTime;

                // è·å–ä¼˜å…ˆæ˜¾ç¤ºçš„ç”¨æˆ·
                const priorityUsers = getTopPriorityUsers(userArray, CHART_CONFIG.MAX_VISIBLE_USERS);
                const activeUserSet = new Set(priorityUsers);

                // æ€§èƒ½æ¨¡å¼ä¸‹çš„æ•°æ®é•¿åº¦
                const dataLength = performanceMode ? CHART_CONFIG.DATA_POINT_LIMIT : MAX_HISTORY_LENGTH;

                // è·å–å½“å‰å›¾è¡¨é…ç½®
                const currentOption = chart.getOption();
                const currentSeries = currentOption.series || [];

                // ç”Ÿæˆæ—¶é—´è½´æ•°æ®
                const xAxisChanged =
                    !chartInitialized || !currentOption.xAxis || !currentOption.xAxis[0] || currentOption.xAxis[0].data.length !== dataLength;
                let xAxisData = [];
                if (xAxisChanged) {
                    for (let i = 0; i < dataLength; i++) {
                        xAxisData.push('');
                    }
                    chartInitialized = true;
                }

                // æ›´æ–°series
                const updatedSeries = [];
                const existingSeriesMap = {};

                // å»ºç«‹ç°æœ‰seriesæ˜ å°„
                currentSeries.forEach((series, index) => {
                    existingSeriesMap[series.name] = { index, series };
                });

                // å¤„ç†æ¯ä¸ªä¼˜å…ˆç”¨æˆ·
                priorityUsers.forEach((userId, index) => {
                    const history = dpsHistory[userId];
                    const user = getUserFromArray(userId);
                    const hasValidName = user?.name && user.name.trim() !== '';
                    const nickname = userNicknames[userId] || (hasValidName ? user.name : '') || `UID:${userId}`;
                    const color = getUserColor(userId); // ä½¿ç”¨å›ºå®šé¢œè‰²åˆ†é…

                    // æ„å»ºæ•°æ®æ•°ç»„
                    const data = new Array(dataLength).fill(null);

                    // å¡«å……çœŸå®æ•°æ®ç‚¹ - ç¨³å®šåŒ–æ—¶é—´æ˜ å°„
                    const timeStep = performanceMode ? 200 : 100;

                    // ä½¿ç”¨å›ºå®šæ—¶é—´åŸºå‡†ï¼Œé¿å…æ»šåŠ¨æ—¶ç´¢å¼•æŠ–åŠ¨
                    const baseTime = Math.floor(currentTime / timeStep) * timeStep;

                    history.forEach((point) => {
                        const timeAgo = baseTime - point.time;
                        const dataIndex = dataLength - 1 - Math.floor(timeAgo / timeStep);
                        if (dataIndex >= 0 && dataIndex < dataLength) {
                            // å¦‚æœè¯¥ä½ç½®å·²æœ‰æ•°æ®ï¼Œå–æœ€å¤§å€¼é¿å…è¦†ç›–å³°å€¼
                            if (data[dataIndex] === null) {
                                data[dataIndex] = point.dps;
                            } else {
                                data[dataIndex] = Math.max(data[dataIndex], point.dps);
                            }
                        }
                    });

                    // æ•°æ®ç¨³å®šåŒ–å¤„ç† - å‡å°‘è •åŠ¨å’Œè·³è·ƒ
                    if (!performanceMode) {
                        // 1. å³°å€¼ä¿æŠ¤ï¼šé¿å…ç›¸é‚»ç‚¹çš„å³°å€¼è·³è·ƒ
                        for (let i = 1; i < data.length - 1; i++) {
                            if (data[i] !== null && data[i - 1] !== null && data[i + 1] !== null) {
                                // å¦‚æœå½“å‰ç‚¹æ˜æ˜¾åç¦»è¶‹åŠ¿ï¼Œå¹³æ»‘å¤„ç†
                                const avg = (data[i - 1] + data[i + 1]) / 2;
                                if (Math.abs(data[i] - avg) > avg * 0.3 && data[i] < avg) {
                                    data[i] = Math.max(data[i], avg * 0.8);
                                }
                            }
                        }

                        // 2. å¡«å……å°é—´éš”ï¼Œä¿æŒè¿ç»­æ€§
                        for (let i = 1; i < data.length; i++) {
                            if (data[i] === null && data[i - 1] !== null) {
                                // çŸ­é—´éš”ç”¨æ¸å˜å¡«å……ï¼Œé¿å…çªç„¶æ–­çº¿
                                let nextIndex = -1;
                                for (let j = i + 1; j < Math.min(i + 3, data.length); j++) {
                                    if (data[j] !== null) {
                                        nextIndex = j;
                                        break;
                                    }
                                }
                                if (nextIndex !== -1 && nextIndex - i <= 2) {
                                    // çº¿æ€§æ’å€¼å¡«å……
                                    const step = (data[nextIndex] - data[i - 1]) / (nextIndex - i + 1);
                                    data[i] = data[i - 1] + step;
                                } else {
                                    // ä¿æŒå‰å€¼
                                    data[i] = data[i - 1];
                                }
                            }
                        }
                    }

                    // é‡è¦ç¨‹åº¦åˆ†å±‚æ ·å¼ï¼ˆTop 5çªå‡ºæ˜¾ç¤ºï¼‰
                    const PRIMARY_COUNT = 5;
                    const isPrimary = index < PRIMARY_COUNT;
                    const lineWidth = isPrimary ? 3.0 : 1.2;
                    const opacity = isPrimary ? 1.0 : 0.45;

                    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨åŒåseries
                    if (existingSeriesMap[nickname]) {
                        // æ›´æ–°ç°æœ‰seriesæ•°æ® - é¿å…é‡å»º
                        const existingSeries = existingSeriesMap[nickname].series;
                        updatedSeries.push({
                            ...existingSeries,
                            data: data,
                            lineStyle: {
                                ...existingSeries.lineStyle,
                                color: color,
                                width: lineWidth,
                                opacity: opacity,
                            },
                            itemStyle: {
                                color: color,
                                opacity: opacity,
                            },
                            z: isPrimary ? 3 : 1,
                            zlevel: isPrimary ? 0 : -1,
                        });
                    } else {
                        // åˆ›å»ºæ–°seriesï¼ˆåˆ†å±‚æ˜¾ç¤ºï¼‰
                        updatedSeries.push({
                            name: nickname,
                            type: 'line',
                            data: data,
                            symbol: 'none',
                            smooth: false, // å®Œå…¨å…³é—­å¹³æ»‘é¿å…å½¢æ€æŠ–åŠ¨
                            connectNulls: false,
                            sampling: false, // å…³é—­é‡‡æ ·é¿å…å³°å€¼æ¸¸ç§»
                            animation: false,
                            silent: false,
                            lineStyle: {
                                color: color,
                                width: lineWidth,
                                opacity: opacity,
                            },
                            itemStyle: {
                                color: color,
                                opacity: opacity,
                            },
                            emphasis: {
                                focus: 'series',
                                lineStyle: {
                                    width: lineWidth + 0.7,
                                    opacity: 1,
                                },
                                itemStyle: {
                                    opacity: 1,
                                },
                            },
                            z: isPrimary ? 3 : 1,
                            zlevel: isPrimary ? 0 : -1,
                        });
                    }
                });

                // æ„å»ºå›¾ä¾‹é€‰ä¸­çŠ¶æ€å¯¹è±¡
                const legendSelected = {};
                updatedSeries.forEach((series) => {
                    const seriesName = series.name;
                    // æ£€æŸ¥æ˜¯å¦æ˜¯UIDæ ¼å¼çš„æ˜µç§°
                    const uidMatch = seriesName.match(/UID:(\d+)/);
                    let userId = null;

                    if (uidMatch) {
                        userId = uidMatch[1];
                    } else {
                        // æŸ¥æ‰¾è‡ªå®šä¹‰æ˜µç§°å¯¹åº”çš„userId
                        userId = Object.keys(userNicknames).find((id) => userNicknames[id] === seriesName);
                    }

                    // ç¡®ä¿userIdæ˜¯å­—ç¬¦ä¸²ç±»å‹è¿›è¡Œæ¯”è¾ƒ
                    const userIdStr = userId ? String(userId) : null;

                    // æ ¹æ®visibleUsersè®¾ç½®å›¾ä¾‹é€‰ä¸­çŠ¶æ€
                    legendSelected[seriesName] = !(userIdStr && visibleUsers[userIdStr] === false);
                });

                // yè½´è°ƒæ•´ç®—æ³•
                const visibleMax = getVisibleMaxFromSeries(updatedSeries);

                // è®©å¯è§æœ€å¤§å€¼å çº¦75%å›¾é«˜ï¼Œå‘ä¸Šå–æ•´
                let proposedTop = visibleMax > 0 ? niceCeil(visibleMax / 0.75) : Y_AXIS_FLOOR_MIN;

                // ä¿åº•æœ€å°å€¼
                proposedTop = Math.max(proposedTop, Y_AXIS_FLOOR_MIN);

                // åŠ 3%é¡¶éƒ¨ä½™é‡é˜²å‹é¡¶
                proposedTop = Math.max(proposedTop, visibleMax * 1.03);

                // ä¸Šå¿«ä¸‹æ…¢ + çŸ­æš‚æ»å
                const DOWN_FRAC = 0.85;
                const DOWN_DWELL_MS = 1500;
                const nowTs = Date.now();
                window.__ymax_state = window.__ymax_state || { yMax: 10000, since: 0 };

                let { yMax: curTop, since } = window.__ymax_state;

                // æ˜¯å¦å…è®¸ä¸‹è°ƒ
                let canDown = false;
                if (visibleMax < curTop * DOWN_FRAC) {
                    if (!since) since = nowTs;
                    canDown = nowTs - since >= DOWN_DWELL_MS;
                } else {
                    since = 0; // åªè¦åˆæ¥è¿‘ä¸Šæ²¿ï¼Œå–æ¶ˆé™è½´è®¡æ—¶
                }

                // åªå…è®¸åœ¨ canDown==true æ—¶æŠŠç›®æ ‡è®¾å¾—æ¯”å½“å‰ä½
                if (!canDown && proposedTop < curTop) proposedTop = curTop;

                // é™åˆ¶å•å¸§æœ€å¤§é™å¹…
                const MAX_DROP = 0.15;
                if (proposedTop < curTop * (1 - MAX_DROP)) {
                    proposedTop = curTop * (1 - MAX_DROP);
                }

                // å¹³æ»‘ä¸€æ­¥
                const alpha = proposedTop > curTop ? 0.35 : 0.18;
                curTop = curTop + alpha * (proposedTop - curTop);

                // å¾®æŠ–æ”¶æ•›
                if (Math.abs(curTop - proposedTop) < 1) curTop = proposedTop;

                // æ›´æ–°çŠ¶æ€
                window.__ymax_state = { yMax: curTop, since };

                // åˆå¹¶æ‰€æœ‰é…ç½®ä¸ºä¸€æ¬¡setOptionè°ƒç”¨
                chart.setOption(
                    {
                        // å¦‚æœè¿™æ¬¡ x è½´é•¿åº¦æ”¹å˜ï¼Œä¹Ÿä¸€èµ·å¸¦ä¸Š
                        ...(xAxisChanged
                            ? {
                                  xAxis: {
                                      data: xAxisData,
                                      axisLine: {
                                          lineStyle: {
                                              color: document.body.classList.contains('dark-mode')
                                                  ? 'rgba(180,180,180,0.25)'
                                                  : 'rgba(100,100,100,0.4)',
                                          },
                                      },
                                      axisTick: {
                                          lineStyle: {
                                              color: document.body.classList.contains('dark-mode')
                                                  ? 'rgba(180,180,180,0.25)'
                                                  : 'rgba(100,100,100,0.4)',
                                          },
                                      },
                                      axisLabel: {
                                          color: document.body.classList.contains('dark-mode') ? 'rgba(220,220,220,0.65)' : 'rgba(60,60,60,0.8)',
                                      },
                                      splitLine: {
                                          show: true,
                                          lineStyle: {
                                              color: document.body.classList.contains('dark-mode')
                                                  ? 'rgba(200,200,200,0.12)'
                                                  : 'rgba(150,150,150,0.3)',
                                              type: 'dashed',
                                          },
                                      },
                                  },
                              }
                            : {}),
                        series: updatedSeries,
                        legend: {
                            data: updatedSeries.map((s) => s.name),
                            selected: legendSelected,
                            textStyle: {
                                color: document.body.classList.contains('dark-mode') ? '#E6E6E6' : '#444',
                            },
                        },
                        yAxis: {
                            type: 'value',
                            name: 'DPS',
                            nameTextStyle: {
                                color: document.body.classList.contains('dark-mode') ? 'rgba(220,220,220,0.8)' : '#333',
                                fontSize: 12,
                            },
                            min: 0,
                            max: curTop,
                            splitNumber: 6,
                            animation: false,
                            axisLine: {
                                lineStyle: {
                                    color: document.body.classList.contains('dark-mode') ? 'rgba(180,180,180,0.25)' : 'rgba(100,100,100,0.4)',
                                },
                            },
                            axisTick: {
                                lineStyle: {
                                    color: document.body.classList.contains('dark-mode') ? 'rgba(180,180,180,0.25)' : 'rgba(100,100,100,0.4)',
                                },
                            },
                            axisLabel: {
                                color: document.body.classList.contains('dark-mode') ? 'rgba(220,220,220,0.65)' : 'rgba(60,60,60,0.8)',
                                fontSize: 11,
                                formatter: function (value) {
                                    if (value >= 1000) {
                                        return (value / 1000).toFixed(1) + 'K';
                                    }
                                    return value;
                                },
                            },
                            splitLine: {
                                lineStyle: {
                                    color: document.body.classList.contains('dark-mode') ? 'rgba(200,200,200,0.12)' : 'rgba(150,150,150,0.3)',
                                    type: 'dashed',
                                },
                            },
                        },
                        tooltip: {
                            backgroundColor: document.body.classList.contains('dark-mode') ? 'rgba(32,32,40,0.92)' : 'rgba(255,255,255,0.95)',
                            borderColor: document.body.classList.contains('dark-mode') ? 'rgba(255,255,255,0.12)' : 'rgba(0,0,0,0.15)',
                            textStyle: { color: document.body.classList.contains('dark-mode') ? '#EEE' : '#333' },
                        },
                        grid: { left: 56, right: '4%', bottom: '8%', top: '15%', containLabel: true },
                    },
                    false,
                    true,
                );

                // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                updateChartStatus(priorityUsers.length, Object.keys(dpsHistory).length);
            }

            // æ›´æ–°å›¾è¡¨çŠ¶æ€æ˜¾ç¤º
            function updateChartStatus(visibleCount, totalCount) {
                const statusElement = document.getElementById('chartStatus');
                if (!statusElement) return;

                statusElement.textContent = `æ˜¾ç¤º ${visibleCount}/${totalCount} ç”¨æˆ·`;
                statusElement.style.color = '#666';
            }

            // æ›´æ–°ç”¨æˆ·æ§åˆ¶åˆ—è¡¨
            function updateUserControlsList(userArray) {
                const controlsList = document.getElementById('userControlsList');
                const existingControls = new Set(Array.from(controlsList.children).map((el) => el.dataset.userId));

                for (const user of userArray) {
                    const userIdStr = String(user.id);

                    if (existingControls.has(userIdStr)) {
                        // æ›´æ–°å·²å­˜åœ¨æ§ä»¶çš„å¤é€‰æ¡†çŠ¶æ€
                        const existingControl = controlsList.querySelector(`[data-user-id="${userIdStr}"]`);
                        if (existingControl) {
                            const checkbox = existingControl.querySelector('.visibility-checkbox');
                            const isVisible = visibleUsers[userIdStr] !== false;
                            checkbox.checked = isVisible;
                        }
                        continue;
                    }

                    const hasValidName = user.name && user.name.trim() !== '';
                    const nickname = userNicknames[userIdStr] || (hasValidName ? user.name : '') || `UID:${user.id}`;
                    const isVisible = visibleUsers[userIdStr] !== false;

                    const controlDiv = document.createElement('div');
                    controlDiv.className = 'user-controls';
                    controlDiv.dataset.userId = userIdStr;
                    const placeholderText = hasValidName ? user.name : 'æ˜µç§°';
                    controlDiv.innerHTML = `
                    <input type="checkbox" class="visibility-checkbox" ${isVisible ? 'checked' : ''} onchange="toggleUserVisibility(${user.id}, this.checked)">
                    <input type="text" class="user-nickname-input" value="${userNicknames[userIdStr] || ''}" placeholder="${placeholderText}" onchange="updateNickname(${user.id}, this.value)" oninput="updateNickname(${user.id}, this.value)">
                    <span class="user-uid">(UID:${user.id})</span>
                `;

                    controlsList.appendChild(controlDiv);
                }
            }

            // æ›´æ–°æ˜µç§°
            function updateNickname(userId, nickname) {
                if (nickname.trim()) {
                    userNicknames[userId] = nickname.trim();
                } else {
                    delete userNicknames[userId];
                }
                localStorage.setItem('userNicknames', JSON.stringify(userNicknames));
            }

            // åˆ‡æ¢ç”¨æˆ·å¯è§æ€§
            function toggleUserVisibility(userId, isVisible) {
                // ç¡®ä¿userIdæ˜¯å­—ç¬¦ä¸²ç±»å‹
                const userIdStr = String(userId);

                if (isVisible) {
                    delete visibleUsers[userIdStr];
                } else {
                    visibleUsers[userIdStr] = false;
                }
                localStorage.setItem('visibleUsers', JSON.stringify(visibleUsers));

                // ä½¿ç”¨EChartsçš„dispatchActionæ¥åˆ‡æ¢å›¾ä¾‹ï¼Œè¿™æ ·ä¸å›¾ä¾‹ç‚¹å‡»è¡Œä¸ºå®Œå…¨ä¸€è‡´
                if (chart) {
                    // è®¾ç½®æ ‡å¿—é˜²æ­¢é€’å½’è§¦å‘
                    isUpdatingFromLegend = true;

                    // æ‰¾åˆ°å¯¹åº”çš„seriesåç§°
                    const user = getUserFromArray(userId);
                    const hasValidName = user?.name && user.name.trim() !== '';
                    const nickname = userNicknames[userIdStr] || (hasValidName ? user.name : '') || `UID:${userId}`;

                    // é€šè¿‡ECharts APIåˆ‡æ¢å›¾ä¾‹é€‰ä¸­çŠ¶æ€
                    chart.dispatchAction({
                        type: 'legendToggleSelect',
                        name: nickname,
                    });

                    // é‡ç½®æ ‡å¿—
                    setTimeout(() => {
                        isUpdatingFromLegend = false;
                    }, 100);
                }
            }

            // å…¨é€‰/å–æ¶ˆå…¨é€‰
            function toggleAllUsers() {
                const checkboxes = document.querySelectorAll('.visibility-checkbox');
                const allChecked = Array.from(checkboxes).every((cb) => cb.checked);

                // æ‰¹é‡æ›´æ–°æ‰€æœ‰ç”¨æˆ·çš„å¯è§æ€§çŠ¶æ€
                checkboxes.forEach((cb) => {
                    cb.checked = !allChecked;
                    const userId = cb.parentElement.dataset.userId;

                    if (!allChecked) {
                        // å…¨é€‰ï¼šæ˜¾ç¤ºæ‰€æœ‰ç”¨æˆ·
                        delete visibleUsers[userId];
                    } else {
                        // å–æ¶ˆå…¨é€‰ï¼šéšè—æ‰€æœ‰ç”¨æˆ·
                        visibleUsers[userId] = false;
                    }
                });

                localStorage.setItem('visibleUsers', JSON.stringify(visibleUsers));

                // æ‰¹é‡åŒæ­¥å›¾ä¾‹çŠ¶æ€
                if (chart) {
                    checkboxes.forEach((cb) => {
                        const userId = cb.parentElement.dataset.userId;
                        const user = getUserFromArray(userId);
                        const hasValidName = user?.name && user.name.trim() !== '';
                        const nickname = userNicknames[userId] || (hasValidName ? user.name : '') || `UID:${userId}`;

                        // è®¾ç½®æ ‡å¿—é˜²æ­¢é€’å½’è§¦å‘
                        isUpdatingFromLegend = true;

                        // é€šè¿‡ECharts APIåŒæ­¥å›¾ä¾‹çŠ¶æ€
                        if (!allChecked) {
                            // å…¨é€‰ï¼šæ˜¾ç¤ºå›¾ä¾‹
                            chart.dispatchAction({
                                type: 'legendSelect',
                                name: nickname,
                            });
                        } else {
                            // å–æ¶ˆå…¨é€‰ï¼šéšè—å›¾ä¾‹
                            chart.dispatchAction({
                                type: 'legendUnSelect',
                                name: nickname,
                            });
                        }
                    });

                    // é‡ç½®æ ‡å¿—
                    setTimeout(() => {
                        isUpdatingFromLegend = false;
                    }, 200);
                }

                // è§¦å‘æ•°æ®æ›´æ–°ï¼Œé‡æ–°æ¸²æŸ“è¡¨æ ¼
                fetchData();
            }

            // æ¸…ç©ºæ‰€æœ‰æ˜µç§°
            function clearNicknames() {
                if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰è‡ªå®šä¹‰æ˜µç§°å—ï¼Ÿ')) {
                    userNicknames = {};
                    localStorage.setItem('userNicknames', JSON.stringify(userNicknames));

                    // æ¸…ç©ºæ§åˆ¶é¢æ¿ä¸­çš„æ‰€æœ‰æ˜µç§°è¾“å…¥æ¡†
                    document.querySelectorAll('.user-nickname-input').forEach((input) => {
                        input.value = '';
                    });
                }
            }

            // åˆ‡æ¢æ§åˆ¶é¢æ¿å¼¹çª—æ˜¾ç¤º/éšè—
            function toggleControlsModal() {
                const modal = document.getElementById('controlsModal');
                const isVisible = modal.style.display === 'block';

                if (isVisible) {
                    modal.style.display = 'none';
                } else {
                    modal.style.display = 'block';
                }
            }

            // åˆ‡æ¢æ§åˆ¶é¢æ¿å¼¹çª—æ˜¾ç¤º/éšè—
            function toggleHistoryModal() {
                const modal = document.getElementById('historyModal');
                const iframe = document.getElementById('historyIframe');
                const isVisible = modal.style.display === 'block';

                if (isVisible) {
                    modal.style.display = 'none';
                    iframe.src = '';
                } else {
                    modal.style.display = 'block';
                    iframe.src = 'history.html';
                }
            }

            // ç‚¹å‡»å¼¹çª—å¤–éƒ¨åŒºåŸŸå…³é—­å¼¹çª—
            window.onclick = function (event) {
                const controlsModal = document.getElementById('controlsModal');
                const columnModal = document.getElementById('columnSettingsModal');
                const skillModal = document.getElementById('skillModal');
                const settingsModal = document.getElementById('settingsModal');
                if (event.target === controlsModal) {
                    toggleControlsModal();
                } else if (event.target === columnModal) {
                    closeColumnSettings();
                } else if (event.target === skillModal) {
                    closeSkillModal();
                } else if (event.target === settingsModal) {
                    toggleSettingsModal();
                }
            };

            // åˆ—æ˜¾ç¤ºè®¾ç½®ç›¸å…³åŠŸèƒ½
            let columnVisibility = {
                uid: true,
                nickname: true,
                job: true,
                score: true,
                hp: true,
                takenDamage: true,
                deadCount: true,
                critRate: true,
                luckyRate: true,
                totalDamage: true,
                pureCrit: true,
                pureLucky: true,
                critLucky: true,
                realtimeDps: true,
                realtimeDpsMax: true,
                dps: true,
                totalHealing: true,
                healingPureCrit: true,
                healingPureLucky: true,
                healingCritLucky: true,
                realtimeHps: true,
                realtimeHpsMax: true,
                hps: true,
                actions: true,
            };

            // ä»localStorageåŠ è½½åˆ—æ˜¾ç¤ºè®¾ç½®
            function loadColumnSettings() {
                const saved = localStorage.getItem('columnVisibility');
                if (saved) {
                    columnVisibility = { ...columnVisibility, ...JSON.parse(saved) };
                }
                updateColumnCheckboxes();
                applyColumnVisibility();
            }

            // ä¿å­˜åˆ—æ˜¾ç¤ºè®¾ç½®åˆ°localStorage
            function saveColumnSettings() {
                localStorage.setItem('columnVisibility', JSON.stringify(columnVisibility));
            }

            // æ›´æ–°å¤é€‰æ¡†çŠ¶æ€
            function updateColumnCheckboxes() {
                Object.keys(columnVisibility).forEach((column) => {
                    const checkbox = document.querySelector(`#col-${column}`);
                    if (checkbox) {
                        checkbox.checked = columnVisibility[column];
                    }
                });
            }

            // æ‰“å¼€åˆ—è®¾ç½®å¼¹çª—
            function openColumnSettings() {
                generateColumnSettingsContent();
                document.getElementById('columnSettingsModal').style.display = 'flex';
            }

            // å…³é—­åˆ—è®¾ç½®å¼¹çª—
            function closeColumnSettings() {
                document.getElementById('columnSettingsModal').style.display = 'none';
            }

            // åŠ¨æ€ç”Ÿæˆåˆ—è®¾ç½®å†…å®¹
            function generateColumnSettingsContent() {
                const modal = document.getElementById('columnSettingsModal');
                const content = modal.querySelector('.column-settings-content');

                // æ¸…é™¤ç°æœ‰å†…å®¹ï¼ˆä¿ç•™æ ‡é¢˜ï¼‰
                const existingGroups = content.querySelectorAll('.column-group');
                existingGroups.forEach((group) => group.remove());

                const isSimpleMode = document.body.classList.contains('simple-mode');

                // åŸºç¡€ä¿¡æ¯ç»„
                const baseGroup = createColumnGroup('ğŸ”° åŸºç¡€ä¿¡æ¯', [
                    { id: 'uid', label: 'è§’è‰²ID', column: 'uid' },
                    { id: 'nickname', label: 'è§’è‰²æ˜µç§°', column: 'nickname' },
                    { id: 'job', label: 'èŒä¸š', column: 'job' },
                    { id: 'score', label: 'è¯„åˆ†', column: 'score' },
                    { id: 'hp', label: 'HP', column: 'hp' },
                    { id: 'takenDamage', label: 'æ‰¿ä¼¤', column: 'takenDamage' },
                    { id: 'deadCount', label: 'æ­»äº¡', column: 'deadCount' },
                    { id: 'critRate', label: 'æš´å‡»ç‡', column: 'critRate' },
                    { id: 'luckyRate', label: 'å¹¸è¿ç‡', column: 'luckyRate' },
                ]);
                content.appendChild(baseGroup);

                // æ ¹æ®å½“å‰æ•°æ®ç»„æ˜¾ç¤ºç›¸åº”çš„åˆ—è®¾ç½®
                if (currentDataGroup === 'damage' || currentDataGroup === 'all') {
                    // ä¼¤å®³æ•°æ®ç»„
                    const damageOptions = [{ id: 'totalDamage', label: 'æ€»ä¼¤å®³', column: 'totalDamage' }];

                    if (!isSimpleMode) {
                        damageOptions.push(
                            { id: 'pureCrit', label: 'çº¯æš´å‡»', column: 'pureCrit' },
                            { id: 'pureLucky', label: 'çº¯å¹¸è¿', column: 'pureLucky' },
                            { id: 'critLucky', label: 'æš´å‡»å¹¸è¿', column: 'critLucky' },
                        );
                    }

                    const damageGroup = createColumnGroup('âš”ï¸ ä¼¤å®³æ•°æ®', damageOptions);
                    content.appendChild(damageGroup);

                    // DPSæ•°æ®ç»„
                    const dpsGroup = createColumnGroup('âš¡ DPSæ•°æ®', [
                        { id: 'realtimeDps', label: 'ç¬æ—¶DPS', column: 'realtimeDps' },
                        { id: 'realtimeDpsMax', label: 'æœ€å¤§ç¬æ—¶', column: 'realtimeDpsMax' },
                        { id: 'dps', label: 'æ€»DPS', column: 'dps' },
                    ]);
                    content.appendChild(dpsGroup);
                }

                if (currentDataGroup === 'healing' || currentDataGroup === 'all') {
                    // æ²»ç–—æ•°æ®ç»„
                    const healingOptions = [{ id: 'totalHealing', label: 'æ€»æ²»ç–—', column: 'totalHealing' }];

                    if (!isSimpleMode) {
                        healingOptions.push(
                            { id: 'healingPureCrit', label: 'çº¯æš´å‡»', column: 'healingPureCrit' },
                            { id: 'healingPureLucky', label: 'çº¯å¹¸è¿', column: 'healingPureLucky' },
                            { id: 'healingCritLucky', label: 'æš´å‡»å¹¸è¿', column: 'healingCritLucky' },
                        );
                    }

                    const healingGroup = createColumnGroup('â¤ï¸ æ²»ç–—æ•°æ®', healingOptions);
                    content.appendChild(healingGroup);

                    // HPSæ•°æ®ç»„
                    const hpsGroup = createColumnGroup('ğŸ’š HPSæ•°æ®', [
                        { id: 'realtimeHps', label: 'ç¬æ—¶HPS', column: 'realtimeHps' },
                        { id: 'realtimeHpsMax', label: 'æœ€å¤§ç¬æ—¶', column: 'realtimeHpsMax' },
                        { id: 'hps', label: 'æ€»HPS', column: 'hps' },
                    ]);
                    content.appendChild(hpsGroup);
                }

                // å…¶ä»–ç»„
                const otherGroup = createColumnGroup('ğŸ”§ å…¶ä»–', [{ id: 'actions', label: 'æ“ä½œ', column: 'actions' }]);
                content.appendChild(otherGroup);

                // é‡æ–°ç»‘å®šäº‹ä»¶
                initColumnSettings();
            }

            // åˆ›å»ºåˆ—è®¾ç½®ç»„
            function createColumnGroup(title, options) {
                const group = document.createElement('div');
                group.className = 'column-group';

                const groupTitle = document.createElement('div');
                groupTitle.className = 'column-group-title';
                groupTitle.textContent = title;
                group.appendChild(groupTitle);

                const optionsContainer = document.createElement('div');
                optionsContainer.className = 'column-options';

                options.forEach((option) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'column-option';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `col-${option.id}`;
                    checkbox.setAttribute('data-column', option.column);
                    checkbox.checked = columnVisibility[option.column] || false;

                    const label = document.createElement('label');
                    label.setAttribute('for', `col-${option.id}`);
                    label.textContent = option.label;

                    optionDiv.appendChild(checkbox);
                    optionDiv.appendChild(label);
                    optionsContainer.appendChild(optionDiv);
                });

                group.appendChild(optionsContainer);
                return group;
            }

            // åº”ç”¨åˆ—æ˜¾ç¤ºè®¾ç½®
            function applyColumnVisibility() {
                const table = document.getElementById('damageTable');
                if (!table) return;

                // åŸºç¡€ä¿¡æ¯åˆ—ï¼ˆrowspan=2ï¼‰
                const baseColumns = [
                    { column: 'uid', selector: 'th[title="è§’è‰²å”¯ä¸€æ ‡è¯†ç¬¦"]' },
                    { column: 'nickname', selector: 'th[title="è§’è‰²æ˜µç§°/è‡ªå®šä¹‰æ˜µç§°"]' },
                    { column: 'job', selector: 'th[title="è§’è‰²èŒä¸š"]' },
                    { column: 'score', selector: 'th[title="è§’è‰²è¯„åˆ†"]' },
                    { column: 'hp', selector: 'th[title="è§’è‰²è¡€é‡"]' },
                    { column: 'takenDamage', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­å—åˆ°çš„ä¼¤å®³"]' },
                    { column: 'deadCount', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­æ­»äº¡æ¬¡æ•°"]' },
                    { column: 'critRate', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æš´å‡»ä¼¤å®³æ¬¡æ•°å æ€»ä¼¤å®³æ¬¡æ•°çš„æ¯”ä¾‹"]' },
                    { column: 'luckyRate', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„å¹¸è¿ä¼¤å®³æ¬¡æ•°å æ€»ä¼¤å®³æ¬¡æ•°çš„æ¯”ä¾‹"]' },
                ];

                // åº”ç”¨åŸºç¡€åˆ—çš„æ˜¾ç¤º/éšè—
                baseColumns.forEach(({ column, selector }) => {
                    const isVisible = columnVisibility[column];
                    const headerCell = table.querySelector(selector);
                    if (headerCell) {
                        if (isVisible) {
                            headerCell.style.removeProperty('display');
                        } else {
                            headerCell.style.setProperty('display', 'none', 'important');
                        }
                    }
                });

                // ä¼¤å®³ç›¸å…³åˆ—
                const damageColumns = [
                    { column: 'totalDamage', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„æ€»ä¼¤å®³"]' },
                    { column: 'pureCrit', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„éå¹¸è¿çš„æš´å‡»ä¼¤å®³"]' },
                    { column: 'pureLucky', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„éæš´å‡»çš„å¹¸è¿ä¼¤å®³"]' },
                    { column: 'critLucky', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„æš´å‡»çš„å¹¸è¿ä¼¤å®³"]' },
                ];

                damageColumns.forEach(({ column, selector }) => {
                    const isVisible = columnVisibility[column];
                    const headerCell = table.querySelector(selector);
                    if (headerCell) {
                        if (isVisible) {
                            headerCell.style.removeProperty('display');
                        } else {
                            headerCell.style.setProperty('display', 'none', 'important');
                        }
                    }
                });

                // DPSç›¸å…³åˆ—
                const dpsColumns = [
                    { column: 'realtimeDps', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æœ€è¿‘ä¸€ç§’é€ æˆçš„ä¼¤å®³"]' },
                    { column: 'realtimeDpsMax', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æœ€å¤§ç¬æ—¶DPS"]' },
                    { column: 'dps', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æ€»DPSï¼ˆä»¥ç¬¬ä¸€æ¬¡æŠ€èƒ½ä¸æœ€åä¸€æ¬¡æŠ€èƒ½ä¹‹é—´çš„æ—¶é—´ä½œä¸ºæœ‰æ•ˆæˆ˜æ–—æ—¶é—´è®¡ç®—ï¼‰"]' },
                ];

                dpsColumns.forEach(({ column, selector }) => {
                    const isVisible = columnVisibility[column];
                    const headerCell = table.querySelector(selector);
                    if (headerCell) {
                        if (isVisible) {
                            headerCell.style.removeProperty('display');
                        } else {
                            headerCell.style.setProperty('display', 'none', 'important');
                        }
                    }
                });

                // æ²»ç–—ç›¸å…³åˆ—
                const healingColumns = [
                    { column: 'totalHealing', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„æ€»æ²»ç–—é‡"]' },
                    { column: 'healingPureCrit', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„éå¹¸è¿çš„æš´å‡»æ²»ç–—é‡"]' },
                    { column: 'healingPureLucky', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„éæš´å‡»çš„å¹¸è¿æ²»ç–—é‡"]' },
                    { column: 'healingCritLucky', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­é€ æˆçš„æš´å‡»çš„å¹¸è¿æ²»ç–—é‡"]' },
                ];

                healingColumns.forEach(({ column, selector }) => {
                    const isVisible = columnVisibility[column];
                    const headerCell = table.querySelector(selector);
                    if (headerCell) {
                        if (isVisible) {
                            headerCell.style.removeProperty('display');
                        } else {
                            headerCell.style.setProperty('display', 'none', 'important');
                        }
                    }
                });

                // HPSç›¸å…³åˆ—
                const hpsColumns = [
                    { column: 'realtimeHps', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æœ€è¿‘ä¸€ç§’é€ æˆçš„ä¼¤å®³å’Œæ²»ç–—é‡"]' },
                    { column: 'realtimeHpsMax', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æœ€å¤§ç¬æ—¶HPS"]' },
                    { column: 'hps', selector: 'th[title="è§’è‰²åœ¨æˆ˜æ–—ä¸­çš„æ€»HPSï¼ˆä»¥ç¬¬ä¸€æ¬¡æŠ€èƒ½ä¸æœ€åä¸€æ¬¡æŠ€èƒ½ä¹‹é—´çš„æ—¶é—´ä½œä¸ºæœ‰æ•ˆæˆ˜æ–—æ—¶é—´è®¡ç®—ï¼‰"]' },
                ];

                hpsColumns.forEach(({ column, selector }) => {
                    const isVisible = columnVisibility[column];
                    const headerCell = table.querySelector(selector);
                    if (headerCell) {
                        if (isVisible) {
                            headerCell.style.removeProperty('display');
                        } else {
                            headerCell.style.setProperty('display', 'none', 'important');
                        }
                    }
                });

                // æ“ä½œåˆ—
                const actionsHeader = table.querySelector('th:last-child');
                if (actionsHeader && actionsHeader.textContent.includes('æ“ä½œ')) {
                    if (columnVisibility.actions) {
                        actionsHeader.style.removeProperty('display');
                    } else {
                        actionsHeader.style.setProperty('display', 'none', 'important');
                    }
                }

                // åº”ç”¨è¡¨ä½“å•å…ƒæ ¼çš„æ˜¾ç¤º/éšè—
                applyBodyColumnVisibility();

                // æ›´æ–°colspan
                updateColspan();
            }

            // åº”ç”¨è¡¨ä½“å•å…ƒæ ¼çš„æ˜¾ç¤º/éšè—
            function applyBodyColumnVisibility() {
                const table = document.getElementById('damageTable');
                if (!table) return;

                // è·å–æ‰€æœ‰è¡¨ä½“è¡Œ
                const rows = table.querySelectorAll('tbody tr');

                rows.forEach((row) => {
                    const cells = row.querySelectorAll('td');

                    // åŸºç¡€ä¿¡æ¯åˆ— (0-8)
                    const baseCols = ['uid', 'nickname', 'job', 'score', 'hp', 'takenDamage', 'deadCount', 'critRate', 'luckyRate'];
                    baseCols.forEach((col, index) => {
                        if (cells[index]) {
                            if (columnVisibility[col]) {
                                cells[index].style.removeProperty('display');
                            } else {
                                cells[index].style.setProperty('display', 'none', 'important');
                            }
                        }
                    });

                    // åŠ¨æ€åˆ—éœ€è¦æ ¹æ®å½“å‰æ•°æ®ç»„å’Œç®€æ´æ¨¡å¼æ¥ç¡®å®šä½ç½®
                    let cellIndex = 9; // ä»ç¬¬10åˆ—å¼€å§‹

                    // å¤„ç†ä¼¤å®³ç›¸å…³åˆ—
                    if (currentDataGroup === 'damage' || currentDataGroup === 'all') {
                        // æ€»ä¼¤å®³åˆ—
                        if (cells[cellIndex]) {
                            if (columnVisibility.totalDamage) {
                                cells[cellIndex].style.removeProperty('display');
                            } else {
                                cells[cellIndex].style.setProperty('display', 'none', 'important');
                            }
                        }
                        cellIndex++;

                        // è¯¦ç»†ä¼¤å®³åˆ—ï¼ˆéç®€æ´æ¨¡å¼ï¼‰
                        if (!document.body.classList.contains('simple-mode')) {
                            const detailCols = ['pureCrit', 'pureLucky', 'critLucky'];
                            detailCols.forEach((col) => {
                                if (cells[cellIndex]) {
                                    if (columnVisibility[col]) {
                                        cells[cellIndex].style.removeProperty('display');
                                    } else {
                                        cells[cellIndex].style.setProperty('display', 'none', 'important');
                                    }
                                }
                                cellIndex++;
                            });
                        }

                        // DPSåˆ—
                        const dpsCols = ['realtimeDps', 'realtimeDpsMax', 'dps'];
                        dpsCols.forEach((col) => {
                            if (cells[cellIndex]) {
                                if (columnVisibility[col]) {
                                    cells[cellIndex].style.removeProperty('display');
                                } else {
                                    cells[cellIndex].style.setProperty('display', 'none', 'important');
                                }
                            }
                            cellIndex++;
                        });
                    }

                    // å¤„ç†æ²»ç–—ç›¸å…³åˆ—
                    if (currentDataGroup === 'healing' || currentDataGroup === 'all') {
                        // æ€»æ²»ç–—åˆ—
                        if (cells[cellIndex]) {
                            if (columnVisibility.totalHealing) {
                                cells[cellIndex].style.removeProperty('display');
                            } else {
                                cells[cellIndex].style.setProperty('display', 'none', 'important');
                            }
                        }
                        cellIndex++;

                        // è¯¦ç»†æ²»ç–—åˆ—ï¼ˆéç®€æ´æ¨¡å¼ï¼‰
                        if (!document.body.classList.contains('simple-mode')) {
                            const healingDetailCols = ['healingPureCrit', 'healingPureLucky', 'healingCritLucky'];
                            healingDetailCols.forEach((col) => {
                                if (cells[cellIndex]) {
                                    if (columnVisibility[col]) {
                                        cells[cellIndex].style.removeProperty('display');
                                    } else {
                                        cells[cellIndex].style.setProperty('display', 'none', 'important');
                                    }
                                }
                                cellIndex++;
                            });
                        }

                        // HPSåˆ—
                        const hpsCols = ['realtimeHps', 'realtimeHpsMax', 'hps'];
                        hpsCols.forEach((col) => {
                            if (cells[cellIndex]) {
                                if (columnVisibility[col]) {
                                    cells[cellIndex].style.removeProperty('display');
                                } else {
                                    cells[cellIndex].style.setProperty('display', 'none', 'important');
                                }
                            }
                            cellIndex++;
                        });
                    }

                    // æ“ä½œåˆ—ï¼ˆæœ€åä¸€åˆ—ï¼‰
                    const lastCell = cells[cells.length - 1];
                    if (lastCell) {
                        if (columnVisibility.actions) {
                            lastCell.style.removeProperty('display');
                        } else {
                            lastCell.style.setProperty('display', 'none', 'important');
                        }
                    }
                });
            }

            // æ›´æ–°è¡¨å¤´çš„colspan
            function updateColspan() {
                const table = document.getElementById('damageTable');
                if (!table) return;

                // è®¡ç®—å„ç»„å¯è§åˆ—æ•°
                const damageMainVisible = ['totalDamage', 'pureCrit', 'pureLucky', 'critLucky'].filter((col) => columnVisibility[col]).length;
                const dpsVisible = ['realtimeDps', 'realtimeDpsMax', 'dps'].filter((col) => columnVisibility[col]).length;
                const healingMainVisible = ['totalHealing', 'healingPureCrit', 'healingPureLucky', 'healingCritLucky'].filter(
                    (col) => columnVisibility[col],
                ).length;
                const hpsVisible = ['realtimeHps', 'realtimeHpsMax', 'hps'].filter((col) => columnVisibility[col]).length;

                // æ›´æ–°colspan
                const damageMainHeader = table.querySelector('.damage-main-col');
                const dpsHeader = table.querySelector('.dps-col');
                const healingMainHeader = table.querySelector('.healing-main-col');
                const hpsHeader = table.querySelector('.hps-col');

                if (damageMainHeader) {
                    if (damageMainVisible > 0) {
                        damageMainHeader.setAttribute('colspan', damageMainVisible);
                        damageMainHeader.style.removeProperty('display');
                    } else {
                        damageMainHeader.style.setProperty('display', 'none', 'important');
                    }
                }

                if (dpsHeader) {
                    if (dpsVisible > 0) {
                        dpsHeader.setAttribute('colspan', dpsVisible);
                        dpsHeader.style.removeProperty('display');
                    } else {
                        dpsHeader.style.setProperty('display', 'none', 'important');
                    }
                }

                if (healingMainHeader) {
                    if (healingMainVisible > 0) {
                        healingMainHeader.setAttribute('colspan', healingMainVisible);
                        healingMainHeader.style.removeProperty('display');
                    } else {
                        healingMainHeader.style.setProperty('display', 'none', 'important');
                    }
                }

                if (hpsHeader) {
                    if (hpsVisible > 0) {
                        hpsHeader.setAttribute('colspan', hpsVisible);
                        hpsHeader.style.removeProperty('display');
                    } else {
                        hpsHeader.style.setProperty('display', 'none', 'important');
                    }
                }
            }

            // åˆ—è®¾ç½®å¤é€‰æ¡†å˜åŒ–äº‹ä»¶
            function initColumnSettings() {
                document.querySelectorAll('#columnSettingsModal input[type="checkbox"]').forEach((checkbox) => {
                    checkbox.addEventListener('change', function () {
                        const column = this.getAttribute('data-column');
                        columnVisibility[column] = this.checked;
                        saveColumnSettings();
                        applyColumnVisibility();
                    });
                });
            }

            // åˆå§‹åŒ–åˆ—è®¾ç½®
            document.addEventListener('DOMContentLoaded', function () {
                loadColumnSettings();
                initColumnSettings();
            });

            // é”®ç›˜ESCé”®å…³é—­å¼¹çª—
            document.addEventListener('keydown', function (event) {
                if (event.key === 'Escape') {
                    const controlsModal = document.getElementById('controlsModal');
                    const updateModal = document.getElementById('updateModal');
                    const skillModal = document.getElementById('skillModal');

                    if (controlsModal.style.display === 'block') {
                        toggleControlsModal();
                    } else if (updateModal.style.display === 'block') {
                        closeUpdateModal();
                    } else if (skillModal.style.display === 'block') {
                        closeSkillModal();
                    }
                }
            });

            // åˆå§‹åŒ–
            function initialize() {
                document.getElementById('appTitle').innerText += ` V${CURRENT_VERSION}`;

                initTheme();
                initSimpleMode();
                initSortMode();
                initDataGroup();
                initChartVisibility();
                initPauseState();
                initChart();

                // æ˜¾ç¤ºåˆå§‹è¿æ¥çŠ¶æ€
                showServerStatus('reconnecting', 'ğŸ”„ æ­£åœ¨åˆå§‹åŒ–è¿æ¥...', false);

                // åˆå§‹åŒ–WebSocketè¿æ¥
                initWebSocket();

                // å¯åŠ¨WebSocketè¿æ¥ç›‘æ§
                monitorWebSocketConnection();

                // åªåœ¨åˆå§‹åŒ–æ—¶è·å–ä¸€æ¬¡æ•°æ®ï¼Œåç»­é€šè¿‡WebSocketæ¥æ”¶
                fetchData();

                // æ£€æŸ¥ç‰ˆæœ¬æ›´æ–°ï¼ˆå»¶è¿Ÿ3ç§’æ‰§è¡Œï¼Œé¿å…å½±å“é¡µé¢åŠ è½½ï¼‰
                setTimeout(() => {
                    checkForUpdates();
                    setInterval(checkForUpdates, 60000);
                }, 3000);

                // æ·»åŠ äº‹ä»¶å§”æ‰˜å¤„ç†æŠ€èƒ½æŒ‰é’®ç‚¹å‡»
                const damageTable = document.getElementById('damageTable');
                if (damageTable) {
                    damageTable.addEventListener('click', function (event) {
                        // å¤„ç†æŠ€èƒ½æŒ‰é’®ç‚¹å‡»
                        if (event.target.classList.contains('skill-btn') || event.target.closest('.skill-btn')) {
                            const button = event.target.classList.contains('skill-btn') ? event.target : event.target.closest('.skill-btn');
                            const userId = button.getAttribute('data-user-id');
                            if (userId) {
                                showSkillAnalysis(parseInt(userId));
                            }
                        }
                        // å¤„ç†å¤åˆ¶æŒ‰é’®ç‚¹å‡»
                        else if (event.target.classList.contains('copy-btn') || event.target.closest('.copy-btn')) {
                            const button = event.target.classList.contains('copy-btn') ? event.target : event.target.closest('.copy-btn');
                            const userId = button.getAttribute('data-user-id');
                            if (userId) {
                                copyUserData(parseInt(userId));
                            }
                        }
                    });
                }
            }

            // ç­‰å¾…DOMåŠ è½½å®Œæˆååˆå§‹åŒ–
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initialize);
            } else {
                initialize();
            }
        </script>
        <script>
            function updateTableStickyHeader() {
                const damageTable = document.getElementById('damageTable');
                const damageTableRows = damageTable.querySelectorAll('tr');
                damageTableRows.forEach((row) => {
                    const top = row.offsetTop;
                    row.style.setProperty('--th-top', `${top}px`);
                });
            }
            window.addEventListener('resize', updateTableStickyHeader);
            document.addEventListener('DOMContentLoaded', updateTableStickyHeader);
        </script>

        <!-- åˆ—è®¾ç½®å¼¹çª— -->
        <div id="columnSettingsModal" class="column-settings-modal">
            <div class="column-settings-content">
                <div class="column-settings-header">
                    <div class="column-settings-title">âš™ï¸ è¡¨æ ¼è®¾ç½®</div>
                    <button class="close-btn" onclick="closeColumnSettings()">&times;</button>
                </div>

                <!-- å†…å®¹å°†é€šè¿‡ JavaScript åŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </body>
</html>
